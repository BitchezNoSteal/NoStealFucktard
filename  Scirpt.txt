local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()

local Window = Library.CreateLib("Pepfre FE Script Hub", "DarkTheme")

local Tab = Window:NewTab("FE Script")

local Section = Tab:NewSection("Scripts")

Section:NewButton("Soul Reaper", "FE Soul Reaper", game.Players.LocalPlayer.Character["PlaneModel"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Surfboard"].Handle.Handle:Destroy()
game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Pal Hair"].Handle.Mesh:Destroy() --Pink Hair
game.Players.LocalPlayer.Character["Pink Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Kate Hair"].Handle.Mesh:Destroy() --LavanderHair
game.Players.LocalPlayer.Character["LavanderHair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Robloxclassicred"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Hat1"].Handle.Mesh:Destroy() 

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Arm", "Left Arm"}) do
    local arm = c[v]
    arm.Parent = nil
    arm.Transparency = 1
    arm.Parent = c
end

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Leg", "Left Leg"}) do
    local Leg = c[v]
    Leg.Parent = nil
    Leg.Transparency = 1
    Leg.Parent = c
end

local v3_net, v3_808 = Vector3.new(0, 25.1, 0), Vector3.new(8, 0, 8)
		local function getNetlessVelocity(realPartVelocity)
			local mag = realPartVelocity.Magnitude
			if mag > 1 then
				local unit = realPartVelocity.Unit
				if (unit.Y > 0.25) or (unit.Y < -0.75) then
					return unit * (25.1 / unit.Y)
				end
			end 
			return v3_net + realPartVelocity * v3_808
		end
		local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
       head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -100
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.73,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.73,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.73,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.73,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = Scarf,
				Name = "Neck",
				Part0 = Scarf, --R6parts.torso
				Part1 = Scarf, --R6parts.head
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 0
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") and v.Name == "VANS_Umbrella" then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = Handle
            end
       else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Accessory"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
   end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
    fling = true
end)
mouse.Button1Up:Connect(function()
    fling = false
end)
local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            handle1.RotVelocity = vel
        end
    end)
end
doForSignal(stepped, v3(10000, 10000, 10000))
doForSignal(renderstepped, v3(10000, 10000, 10000))
doForSignal(heartbeat, v3(200000000000000, 200000000000000, 200000000000000)) --https://web.roblox.com/catalog/63690008/Pal-Hair


local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

local hat2 = gp(cplayer, "Hat1", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0.5, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Pal Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(-0.5, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Pink Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Kate Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0) --LavanderHair

local hat2 = gp(cplayer, "LavanderHair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(0, 0, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Robloxclassicred", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, 0, 0) 
att2.Rotation = Vector3.new(90, 0, 0)  

--[[_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('SpecialMesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['VANS_Umbrella'].Handle,char['HumanoidRootPart'],false)
local cf = char['HumanoidRootPart'].CFrame*CFrame.new(0,-10,-0)*CFrame.Angles(math.rad(0),math.rad(0),0)
hat[1].CFrame = cf:Inverse() * char['HumanoidRootPart'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end]] --nvm

local script = game:GetObjects("rbxassetid://13134428195")[1] --important stuff
script.Parent = game:GetService("Players").LocalPlayer


local Player = game:GetService("Players").LocalPlayer Mouse = Player:GetMouse() 
--local Mouse--,mouse,UserInputService,ContextActionService
do
	local CAS = {Actions={}}
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInputEvent"
	Event.Parent = Player.Character
	local fakeEvent = function()
		local t = {_fakeEvent=true}
		t.Connect = function(self,f)self.Function=f end
		t.connect = t.Connect
		return t
	end
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	function CAS:BindAction(name,fun,touch,...)
		CAS.Actions[name] = {Name=name,Function=fun,Keys={...}}
	end
	function CAS:UnbindAction(name)
		CAS.Actions[name] = nil
	end
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent and t.Function then
			t.Function(...)
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te
	Event.OnClientEvent:Connect(function(plr,io)
	    if plr~=Player then return end
		if io.isMouse then
			m.Target = io.Target
			m.Hit = io.Hit
		elseif io.UserInputType == Enum.UserInputType.MouseButton1 then
	        if io.UserInputState == Enum.UserInputState.Begin then
				m:TrigEvent("Button1Down")
			else
				m:TrigEvent("Button1Up")
			end
		else
			for n,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
	        if io.UserInputState == Enum.UserInputState.Begin then
	            m:TrigEvent("KeyDown",io.KeyCode.Name:lower())
				UIS:TrigEvent("InputBegan",io,false)
			else
				m:TrigEvent("KeyUp",io.KeyCode.Name:lower())
				UIS:TrigEvent("InputEnded",io,false)
	        end
	    end
	end)
	--Mouse,mouse,UserInputService,ContextActionService = m,m,UIS,CAS
end

--BasicFunctions
local ins = Instance.new
local v3 = Vector3.new
local cf = CFrame.new
local angles = CFrame.Angles
local rad = math.rad
local huge = math.huge
local cos = math.cos
local sin = math.sin
local tan = math.tan
local abs = math.abs
local ray = Ray.new
local random = math.random
local ud = UDim.new
local ud2 = UDim2.new
local c3 = Color3.new
local rgb = Color3.fromRGB
local bc = BrickColor.new

--Services
local plrs = game:GetService("Players")
local tweens = game:GetService("TweenService")
local debrs = game:GetService("Debris")
local runservice = game:GetService("RunService")
 
--Variables
local plr = Player
local plrg = plr.PlayerGui
local char = plr.Character
local h = char.Head
local t = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local rut = char.HumanoidRootPart
local hum = char:FindFirstChildOfClass("Humanoid")
local nec = t.Neck
local rutj = rut.RootJoint
local rs = t["Right Shoulder"]
local ls = t["Left Shoulder"]
local rh = t["Right Hip"]
local lh = t["Left Hip"]

necc0,necc1=cf(0,t.Size.Y/2,0),cf(0,-h.Size.Y/2,0)
rutjc0,rutjc1=cf(0,0,0),cf(0,0,0)
rsc0,rsc1=cf(t.Size.X/2,t.Size.Y/4,0),cf(-ra.Size.X/2,ra.Size.Y/4,0)
lsc0,lsc1=cf(-t.Size.X/2,t.Size.Y/4,0),cf(la.Size.X/2,la.Size.Y/4,0)
rhc0,rhc1=cf(t.Size.X/4,-t.Size.Y/2,0),cf(0,rl.Size.Y/2,0)
lhc0,lhc1=cf(-t.Size.X/4,-t.Size.Y/2,0),cf(0,ll.Size.Y/2,0)
script.Client.Disabled = false
local muted = false
local using = false

local anim = "idle"
local asset = "rbxassetid://"

local change = 1
local sine = 0

local combo = 1

local timePos = 0
local staticTimePos = 0

local ws = 25
local jp = 65

--
local stepsounds = {
Grass = asset.."1201103066",
Sand = asset.."1436385526",
Plastic = asset.."1569994049",
Stone = asset.."507863857", --379398649
Wood = asset.."1201103959",
Pebble = asset.."1201103211",
Ice = asset.."265653271",
Glass = asset.."145180170",
Metal = asset.."379482691"
}

local directions = {In = Enum.EasingDirection.In,
    Out = Enum.EasingDirection.Out,
    InOut = Enum.EasingDirection.InOut
}

local styles = {Linear = Enum.EasingStyle.Linear,
    Back = Enum.EasingStyle.Back,
    Bounce = Enum.EasingStyle.Bounce,
    Sine = Enum.EasingStyle.Sine,
    Quad = Enum.EasingStyle.Quad,
    Elastic = Enum.EasingStyle.Elastic,
    Quart = Enum.EasingStyle.Quart,
    Quint = Enum.EasingStyle.Quint
}

local swings = {
	2490619022,
	2490619317
}

local stepped = runservice.Heartbeat

--Removing joints/Animations
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end

if hum:FindFirstChildOfClass("Animator") then
	char.Humanoid.Animator:Destroy()
end

hum.MaxHealth = 25000
hum.Health = hum.MaxHealth

nec.Parent = nil
rutj.Parent = nil
rs.Parent = nil
ls.Parent = nil
rh.Parent = nil
lh.Parent = nil

--Joints
local nec = ins("Motor6D",t) nec.Name = "Neck" nec.Part0 = t nec.Part1 = h
local rutj = ins("Motor6D",rut) rutj.Name = "RootJoint" rutj.Part0 = t rutj.Part1 = rut
local rs = ins("Motor6D",t) rs.Name = "Right Shoulder" rs.Part0 = t rs.Part1 = ra
local ls = ins("Motor6D",t) ls.Name = "Left Shoulder" ls.Part0 = t ls.Part1 = la
local rh = ins("Motor6D",t) rh.Name = "Right Hip" rh.Part0 = t rh.Part1 = rl
local lh = ins("Motor6D",t) lh.Name = "Left Hip" lh.Part0 = t lh.Part1 = ll

--Setting CFrames
nec.C1 = necc1
nec.C0 = necc0
rs.C1 = rsc1
rs.C0 = rsc0
ls.C1 = lsc1
ls.C0 = lsc0
rh.C1 = rhc1
rh.C0 = rhc0
lh.C1 = lhc1
lh.C0 = lhc0
rutj.C1 = rutjc1
rutj.C0 = rutjc0

--Functions1
function createWeld(p1,p2,c0,c1)
	c0 = c0 or cf(0,0,0)
	c1 = c1 or cf(0,0,0)
	local weld = ins("Motor6D",p1)
	weld.Part0 = p1
	weld.Part1 = p2
	weld.C0 = c0
	weld.C1 = c1
	return weld
end

--Adds
local damageBil = script.UIs.SPDamageUI

local scythe = script.Models.Scythe
scythe.Parent = char
--scythe.Transparency = 1


local handle = scythe.Handle
local blade = scythe.NeonBlade
blade.Transparency = 1
--Handle.Transparency = 1

game:GetService("Players").LocalPlayer.Character["Surfboard"].Handle.att1_Handle.Parent = handle
handle.att1_Handle.Rotation = Vector3.new(90,0,90)
handle.att1_Handle.Position = Vector3.new(0,2,0) --PlaneModel
 
game:GetService("Players").LocalPlayer.Character["PlaneModel"].Handle.att1_Handle.Parent = blade
blade.att1_Handle.Rotation = Vector3.new(0,0,90)
blade.att1_Handle.Position = Vector3.new(-1,0,0)

local handleWeld = createWeld(ra,handle,cf(0,-1,0) * angles(rad(-90),rad(0),rad(0)))

local shadow = ins("Model",char)
shadow.Name = "Shadow"

local ff = ins("ForceField",char)
ff.Visible = false

local effects = ins("Model",char)
effects.Name = "Effects"

local theme = ins("Sound",t)
theme.Volume = 1.5
theme.SoundId = asset..1493059596
theme.Looped = true
theme:Play()

local static = ins("Sound",blade)
static.Volume = 1
static.SoundId = asset..1080752200
static.Looped = true
static:Play()

function createShadow(p,off,trans)
	if trans >1 then
		return
	end
	local pa = ins("Part",shadow)
	pa.Size = v3(.1*p.Size.x,.1*p.Size.y,.1*p.Size.z)
	pa.Material = "Plastic"
	pa.CanCollide = false
	pa.Locked = true
	pa.Color = c3(0,0,0)
	pa.Transparency = trans
	pa.Massless = true
	pa.Name = "Shadow"
	local mesh = ins("SpecialMesh",pa)
	mesh.Scale = v3(1.255,1.265/2,1.255) * 10
	mesh.Offset = v3(0,off,0)
	local weld = createWeld(p,pa,cf(0,0,0),cf(0,0,0))
	return pa
end

local off = .325*h.Size.y
for i = .325*h.Size.y,-.15*h.Size.y,-.0045*h.Size.y do
	local e = createShadow(h,off,1 - i*2.75)
	off = off -.0075*h.Size.y
end

local shaker = script.DistShaker:Clone()

--Functions2

function remove(instance,time)
	time = time or 0
	game:GetService("Debris"):AddItem(instance,time)
end

function swait()
	game:GetService("RunService").Stepped:Wait()
end

function rayc(spos,direc,ignore,dist)
    local rai = ray(spos,direc.Unit * dist)
    local rhit,rpos,rrot = workspace:FindPartOnRayWithIgnoreList(rai,ignore,false,false)
    return rhit,rpos,rrot
end

function sound(id,vol,pitch,parent,maxdist)
	local mdist = 30 or maxdist
	local newsound = Instance.new("Sound",parent)
	newsound.Volume = vol
	newsound.SoundId = "rbxassetid://"..id
	newsound.Pitch = pitch
	newsound:Play()
	coroutine.resume(coroutine.create(function()
		wait(.1)
		remove(newsound,newsound.TimeLength/newsound.Pitch)
	end))
	return newsound
end

function placesoundpart(rcf,id,vol,pitch,maxdist)
	pcall(function()
		local mdist = 30 or maxdist
		local spart = ins("Part",effects)
		spart.Anchored = true
		spart.CanCollide = false
		spart.Locked = true
		spart.Transparency = 1
		spart.CFrame = rcf
		local ssound = sound(id,vol,pitch,spart,mdist)
		remove(spart,ssound.TimeLength/ssound.Pitch)
	end)
end

local tlerp = function(part,tablee,leinght,easingstyle,easingdirec)
    local info = TweenInfo.new(
    leinght,
    easingstyle,
    easingdirec,
    0,
    false,
    0
    )
    local lerp = tweens:Create(part,info,tablee)
    lerp:Play()
end

local Effects = {
	Ring = function(pos,color,sSize,eSize,sTrans,eTrans,time,style)
		style = style or "Linear"
		local ring = script.Effects.Ring:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles[style],directions.Out)
	end,
	SpinningRing = function(pos,color,rotation,sSize,eSize,sTrans,eTrans,time,style)
		style = style or "Linear"
		local ring = script.Effects.Ring:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles[style],directions.Out)
		coroutine.wrap(function()
			repeat
				ring.CFrame = ring.CFrame * rotation
				wait(1/30)
			until not ring.Parent
		end)()
	end,
	Sphere = function(pos,color,sSize,eSize,sTrans,eTrans,time,style)
		style = style or "Linear"
		local sphere = ins("Part")
		sphere.Shape = "Ball"
		sphere.Size = v3(sSize,sSize,sSize)
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		remove(sphere,time)
		tlerp(sphere,{Size = v3(eSize,eSize,eSize),Transparency = eTrans},time,styles[style],directions.Out)
		return sphere
	end,
	Beam = function(pos,color,sLength,eLength,sThickness,eThickness,sTrans,eTrans,time,style)
		style = style or "Linear"
		local sphere = ins("Part")
		sphere.Shape = "Block"
		sphere.Size = v3(sThickness,sLength,sThickness)
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		ins("CylinderMesh",sphere)
		remove(sphere,time)
		tlerp(sphere,{Size = v3(eThickness,eLength,eThickness),Transparency = eTrans},time,styles[style],directions.Out)
	end,
	SpinningBlock = function(pos,color,sSize,eSize,sTrans,eTrans,cfRotation,time,style)
		style = style or "Linear"
		local part = ins("Part")
		part.Size = v3(sSize,sSize,sSize)
		part.Transparency = sTrans
		part.CFrame = pos
		part.Color = color
		part.Parent = effects
		part.Anchored = true
		part.CanCollide = false
		part.Locked = true
		part.Material = "Neon"
		remove(part,time)
		tlerp(part,{Size = v3(eSize,eSize,eSize),Transparency = eTrans},time,styles[style],directions.Out)
		coroutine.wrap(function()
			repeat
				part.CFrame = part.CFrame * cfRotation
				wait(1/30)
			until not part.Parent
		end)()
	end,
	CustomSphere = function(pos,endPos,color,sSize,eSize,sTrans,eTrans,time,style)
		style = style or "Linear"
		local sphere = ins("Part")
		sphere.Size = sSize
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		
		local mesh = ins("SpecialMesh",sphere)
		mesh.MeshType = "Sphere"
		
		remove(sphere,time)
		tlerp(sphere,{Size = eSize,Transparency = eTrans,CFrame = endPos},time,styles[style],directions.Out)
	end,
	CustomSphereBoomerang = function(pos,endPos,color,sSize,eSize,sTrans,eTrans,time,style)
		style = style or "Linear"
		local sphere = ins("Part")
		sphere.Size = sSize
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		
		local mesh = ins("SpecialMesh",sphere)
		mesh.MeshType = "Sphere"
		coroutine.wrap(function()
			remove(sphere,time)
			tlerp(sphere,{Transparency = eTrans},time * 1.25,styles[style],directions.Out)
			tlerp(sphere,{Size = eSize,CFrame = endPos},time/2,styles[style],directions.Out)
			wait(time/2)
			tlerp(sphere,{Size = sSize},time/2,styles[style],directions.Out)
		end)()
	end,
	CustomSphereBoomerangPlusPos = function(pos,endPos,color,sSize,eSize,sTrans,eTrans,time,style)
		style = style or "Linear"
		local sphere = ins("Part")
		sphere.Size = sSize
		sphere.Transparency = sTrans
		sphere.CFrame = pos
		sphere.Color = color
		sphere.Parent = effects
		sphere.Anchored = true
		sphere.CanCollide = false
		sphere.Locked = true
		sphere.Material = "Neon"
		
		local mesh = ins("SpecialMesh",sphere)
		mesh.MeshType = "Sphere"
		coroutine.wrap(function()
			remove(sphere,time)
			tlerp(sphere,{Transparency = eTrans},time * 1.25,styles[style],directions.Out)
			tlerp(sphere,{Size = eSize,CFrame = endPos},time/2,styles[style],directions.Out)
			wait(time/2)
			tlerp(sphere,{Size = sSize,CFrame = pos},time/2,styles[style],directions.Out)
		end)()
	end,
	Wind = function(pos,color,rotation,sSize,eSize,sTrans,eTrans,time,style)
		style = style or "Linear"
		local ring = script.Effects.Wind:Clone()
		ring.Size = sSize
		ring.Transparency = sTrans
		ring.CFrame = pos
		ring.Color = color
		ring.Parent = effects
		remove(ring,time)
		tlerp(ring,{Size = eSize,Transparency = eTrans},time,styles[style],directions.Out)
		coroutine.wrap(function()
			repeat
				ring.CFrame = ring.CFrame * angles(rad(0),rad(rotation),rad(0))
				wait(1/30)
			until not ring.Parent
		end)()
	end,
	CreateCamShake = function(part,maxDist,intensivity,time)
		maxDist = maxDist or 20
		intensivity = intensivity or 1
		time = time or .1
		
		local bool = ins("BoolValue",part)
		bool.Name = "Shaking"
		bool.Value = true
		
		local MaxDist = ins("NumberValue",bool)
		MaxDist.Name = "MaxDist"
		MaxDist.Value = maxDist
		
		local Intensivity = ins("NumberValue",bool)
		Intensivity.Name = "Intensivity"
		Intensivity.Value = intensivity
		
		remove(bool,time)
	end,
	SoundEffect = function(sound,effect)
		ins(effect.."SoundEffect",sound)
	end
}

function death(whom)
	coroutine.wrap(function()
		if whom then
			whom:BreakJoints()
			remove(whom,7.5)
			local p = whom:FindFirstChildWhichIsA("BasePart")
			if p then
				placesoundpart(p.CFrame,1835350947,2.5,random(120,130)/100,5)
			end
			for i,v in pairs(whom:GetChildren()) do
				if v:IsA("BasePart") then
					coroutine.wrap(function()
						local clon = v:Clone()
						remove(v)
						clon.Anchored = true
						clon.Massless = true
						clon.CanCollide = false
						clon.Locked = true
						clon.Material = "Neon"
						clon.CFrame = v.CFrame
						clon.Transparency = 0
						clon:ClearAllChildren()
						clon.Color = bc("Royal purple").Color
						if clon.Name == "Head" then
							clon.Size = v3(clon.Size.Z,clon.Size.Z,clon.Size.Z)
						end
						clon.Parent = effects
						local ori = clon.Orientation
						local pos = clon.Position
						local time = random(15,30)/10 * (clon.Size).Magnitude
						local size = clon.Size
						coroutine.wrap(function()
							for i = 1,time,time/20 do
								local c = clon.CFrame * cf(random(-(clon.Size.X * 10),(clon.Size.X * 10))/20,random(-(clon.Size.Y * 10),(clon.Size.Y * 10))/20,random(-(clon.Size.Z * 10),(clon.Size.Z * 10))/20)
								Effects.CustomSphere(cf(c.Position),cf(c.Position) * cf(0,(-random(10,25)/10) * (clon.Size).Magnitude,0),bc("Royal purple").Color,v3(.15,.15,.15) * (clon.Size).Magnitude,v3(0,1,0) * (clon.Size).Magnitude,clon.Transparency,1,(random(15,30)/100) * (clon.Size).Magnitude,"Linear")
								wait(time/20)
							end
						end)()
						remove(clon,time)
						tlerp(clon,{Position = pos + v3(0,(random(5,15)/10) * (clon.Size).Magnitude,0),Orientation = ori + v3(random(-15,15),random(-15,15),random(-15,15)) * (clon.Size).Magnitude,Transparency = 1},time,styles.Quart,directions.Out)
						tlerp(clon,{Size = size * .5},time/2,styles.Back,directions.InOut)
						wait(time/2)
						tlerp(clon,{Size = size * 1.5},time/2,styles.Linear,directions.Out)
					end)()
				else
					remove(v)
				end
			end
		end
	end)()
end

function showDamage(pos,text,time,animTime)
	coroutine.wrap(function()
		pos = pos or t.CFrame
		text = text or "NULL"
		time = time or 2
		animTime = animTime or .5
	
		local clon = damageBil:Clone()
		local backG = clon.MainFrame
		local tex = backG.Damage
		local dFrame = clon.DropsFrame
		local drop = dFrame.Drop
		local p = ins("Part")
		
		p.Locked = true
		p.Massless = true
		p.CanCollide = false
		p.Anchored = true
		p.Size = v3(0,0,0)
		p.Transparency = 1
		p.CFrame = cf(pos.Position) * cf(random(-25,25)/10,random(-25,25)/10,random(-25,25)/10)
		p.Parent = effects
		
		clon.Parent = p
		drop.Parent = nil
		drop.Visible = true
		
		tex.Text = text
		
		remove(p,time + (animTime * 2))
		
		coroutine.wrap(function()
			repeat
				if p.Parent ~= effects then
					remove(p)
				end
				local dClon = drop:Clone()
				local dropPos = random(0,100)/100
				local dropSize = random(5,15)/100
				local growTime = random(15,25)/100
				local fallTime = random(7,15)/100
				local fallDelay = random(7,15)/100
				
				dClon.Parent = dFrame
				dClon.Position = ud2(dropPos,0,0,0)
				dClon.Size = ud2(0,0,0,0)
				dClon.ImageTransparency = 1
				dClon.Visible = true
				
				coroutine.wrap(function()
					remove(dClon,growTime + fallTime + fallDelay)
					tlerp(dClon,{ImageTransparency = backG.BackgroundTransparency,Size = ud2(dropSize,0,dropSize,0)},growTime,styles.Sine,directions.Out)
					wait(growTime + fallDelay)
					tlerp(dClon,{ImageTransparency = 1,Size = ud2(dropSize/2,0,dropSize * 12.5,0)},fallTime,styles.Sine,directions.Out)
				end)()
				
				wait(random(5,15)/100)
			until not p.Parent
		end)()
		
		tlerp(backG,{BackgroundTransparency = .5},animTime,styles.Back,directions.In)
		tlerp(tex,{TextTransparency = 0,TextStrokeTransparency = 0},animTime,styles.Back,directions.In)
		
		wait(time)
		
		tlerp(backG,{BackgroundTransparency = 1},animTime,styles.Back,directions.In)
		tlerp(tex,{TextTransparency = 1,TextStrokeTransparency = 1},animTime,styles.Back,directions.In)
	end)()
end

function damage(humanoid,Damage,knockback,knockbackStartPoint,knockbackTime,knockDelay,damageSound)
	Damage = Damage or random(0,0)
	knockback = knockback or 15
	knockbackStartPoint = knockbackStartPoint or v3(0,0,0)
	knockbackTime = knockbackTime or .15
	knockDelay = knockDelay or .2
	damageSound = damageSound or sound(851453784,1.5,random(90,110)/100,nil,1)
	if humanoid and not humanoid:FindFirstChild("Dbounce'd") and humanoid.Health > .01 then
		Damage = math.floor(Damage * (0 + humanoid.MaxHealth/0))
		local part = humanoid.Parent:FindFirstChildOfClass("Part") or humanoid.Parent:FindFirstChildOfClass("MeshPart")
		local deb = ins("BoolValue",humanoid)
		deb.Name = "Dbounce'd"
		remove(deb,knockDelay)
		if part then
			damageSound.Parent = part
			local knock = ins("BodyVelocity",part)
			knock.MaxForce = v3(huge,huge,huge)
			knock.Velocity = -cf(part.Position,knockbackStartPoint).LookVector * knockback
			showDamage(part.CFrame,"-"..Damage,random(0,0)/0,0)
			remove(knock,knockbackTime)
		end
		if humanoid.MaxHealth > 0 then
			sound(1753674936,5,1,t,5)
			death(humanoid.Parent)
		end
		humanoid.Health = humanoid.Health - Damage
		if humanoid.Health < .01 then
			death(humanoid.Parent)
			if part then
				placesoundpart(part,2801263,15,random(90,110)/100,1)
			end
		end
	end
end

--[[function magDamage(pos,partSize,size,Damage,knockback,knockbackTime,knockDelay,damageSound)
	local reg
	local knockPoint
	if typeof(pos) == "Vector3" then
		reg = Region3.new(pos - v3(size/2,size/2,size/2),pos + v3(size/2,size/2,size/2))
		knockPoint = pos
	elseif typeof(pos) == "Instance" then
		knockPoint = pos.Position
		if partSize then
			reg = Region3.new(pos.CFrame * cf(-pos.Size.X/2,-pos.Size.Y/2,-pos.Size.Y/2).Position,pos.CFrame * cf(pos.Size.X/2,pos.Size.Y/2,pos.Size.Z/2).Position)
		else
			reg = Region3.new(pos.Position - v3(size/2,size/2,size/2),pos.Position + v3(size/2,size/2,size/2))
		end
	end
	if reg then
		for i,v in pairs(workspace:FindPartsInRegion3WithIgnoreList(reg,{char},0)) do
			local humm = v.Parent:FindFirstChildOfClass("Humanoid")
			if humm then
				damage(humm,Damage,knockback,knockPoint,knockbackTime,knockDelay,damageSound)
			end
		end
	end
end]]

function swing1()
	using = true
	local oldWS = ws
	local oldJP = jp
	ws = 4
	jp = 45
	local add = -.035
	local alpha = .5
	sound(swings[random(1,#swings)],2.5,random(60,80)/100,ra,1)
	for i = 0,1,.075 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-5),rad(35),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,.1,-.1) * angles(rad(-5),rad(45),rad(-5)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,-.15,.25) * angles(rad(205),rad(25),rad(0)) * angles(rad(-5),rad(0),rad(15)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(.075,-.15,.15) * angles(rad(15),rad(-25),rad(-7.5)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(2.5),rad(-5),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.05,-.05) * angles(rad(-20),rad(15),rad(-5)),alpha)
		handleWeld.C0 = handleWeld.C0:Lerp(cf(0,-1,0) * angles(rad(-75),rad(10),rad(0)),alpha)
		alpha = alpha + add
		swait()
	end
	alpha = .25
	add = .15
	for i = 0,1,.125 do
		local s = sound(566593606,1.5,random(85,115)/100,nil,2.5)
		s.TimePosition = .075
		--magDamage(blade,false,10,random(15,25),random(20,40),.1,.35,s)
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(2.5),rad(-30),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,.125,.25) * angles(rad(5),rad(-45),rad(5)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,-.25,-.35) * angles(rad(35),rad(-50),rad(0)) * angles(rad(0),rad(0),rad(-7.5)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(.1,-.2,.1) * angles(rad(-15),rad(15),rad(-5)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.05,-.05) * angles(rad(-12.5),rad(-10),rad(2.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(5),rad(5),rad(2.5)),alpha)
		handleWeld.C0 = handleWeld.C0:Lerp(cf(0,-1,0) * angles(rad(-110),rad(20),rad(0)),alpha)
		alpha = alpha + add
		if alpha >1 then
			add = -math.abs(add)
		end
		swait()
	end
	ws = oldWS
	jp = oldJP
	using = false
end

function swing2()
	using = true
	local oldWS = ws
	local oldJP = jp
	ws = 4
	jp = 45
	local add = -.035
	local alpha = .5
	sound(swings[random(1,#swings)],2.5,random(60,80)/100,ra,1)
	for i = 0,1,.075 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(-60),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(2.5),rad(-60),rad(-7.5)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,-.5) * angles(rad(85),rad(95),rad(0)) * angles(rad(20),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.2,.15) * angles(rad(-10),rad(10),rad(-5)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,-.1,0) * angles(rad(-15),rad(-5),rad(-5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,-.1,-.15) * angles(rad(20),rad(5),rad(-10)),alpha)
		handleWeld.C0 = handleWeld.C0:Lerp(cf(0,-1,0) * angles(rad(-85),rad(0),rad(0)),alpha)
		alpha = alpha + add
		swait()
	end
	alpha = .25
	add = .15
	for i = 0,1,.125 do
		local s = sound(566593606,1.5,random(85,115)/100,nil,2.5)
		s.TimePosition = .075
		--magDamage(blade,false,10,random(15,25),random(20,40),.1,.35,s)
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(75),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(-2.5),rad(75),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,-.35) * angles(rad(90),rad(85),rad(0)) * angles(rad(-105),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.25,.25) * angles(rad(25),rad(-35),rad(-7.5)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(15),rad(-5),rad(1.5)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(-15),rad(5),rad(-5)),alpha)
		handleWeld.C0 = handleWeld.C0:Lerp(cf(0,-1,0) * angles(rad(-120),rad(0),rad(0)),alpha)
		alpha = alpha + add
		if alpha >1 then
			add = -math.abs(add)
		end
		swait()
	end
	ws = oldWS
	jp = oldJP
	using = false
end

--[[
	local alpha = .35
	for i = 0,1,.025 do
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),alpha)
		alpha = alpha -.025
		swait()
	end
function base()
	using = true
	local oldWS = ws
	local oldJP = jp
	ws = 0
	jp = 0
	
	ws = oldWS
	jp = oldJP
	using = false
end
--]]

local combos = {swing1,swing2}

mouse.KeyDown:Connect(function(key)
	if not using then
		
	end
	if key == "m" then
		muted = not muted
	end
end)

mouse.Button1Down:Connect(function()
	if not using then
		combos[combo]()
		combo = combo +1
		if combo >#combos then
			combo = 1
		end
	end
end)

stepped:Connect(function()
	sine = sine + change
	
	local verVel = rut.Velocity.y
	local horVel = (rut.Velocity * v3(1,0,1)).Magnitude

	local Ccf=rut.CFrame
	
	local dir = hum.MoveDirection
	
	if dir == v3(0,0,0) then
		dir = rut.Velocity/10
	end
	
	if theme.Parent ~= t then
		remove(theme)
		theme = ins("Sound",t)
		theme.Volume = 1.5
		theme.SoundId = asset..1493059596
		theme.Looped = true
		theme.TimePosition = timePos
		theme:Play()
	end
	
	if static.Parent ~= t then
		remove(static)
		static = ins("Sound",t)
		static.Volume = 1.5
		static.SoundId = asset..1080752200
		static.Looped = true
		static.TimePosition = staticTimePos
		static:Play()
	end
	
	if not muted then
		theme.Volume = 1.5
	else
		theme.Volume = 0
	end
	theme.SoundId = asset..1493059596
	theme.Looped = true
	theme:Resume()
	theme.Name = "Theme"
	
	static.Volume = .75
	static.SoundId = asset..1080752200
	static.Looped = true
	static:Resume()
	static.Name = "Static"
	
	timePos = theme.TimePosition
	staticTimePos = static.TimePosition

	local Walktest1 = dir * Ccf.LookVector
	local Walktest2 = dir * Ccf.RightVector

	local rotfb = Walktest1.X+Walktest1.Z
	local rotrl = Walktest2.X+Walktest2.Z
	
	if rotfb >1 then
		rotfb = 1
	elseif rotfb <-1 then
		rotfb = -1
	end
	
	if rotrl >1 then
		rotrl = 1
	elseif rotrl <-1 then
		rotrl = -1
	end
	
	hum.WalkSpeed = ws
	hum.JumpPower = jp
	
	--[[for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		if not v.PlayerGui:FindFirstChild(shaker.Name) then
			local shak = shaker:Clone()
			shak.Parent = v.PlayerGui
			shak.Disabled = false
		end
    end]]
	
	local hit,pos,nId = rayc(rut.Position + v3(0,-rut.Size.y/2,0),v3(rut.Position.x,-10000,rut.Position.z),{char},3)
	
	if using then
		anim = "idle"
	end
	
	if anim == "idle" and hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/20) * rad(2.5),sin(sine/40) * rad(1),sin(sine/40) * rad(5)),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(sin(sine/40)/15,sin(sine/20)/15,sin(sine/60)/15) * angles(sin(sine/20) * rad(2.5),sin(sine/80) * rad(5),sin(sine/40) * rad(2.5)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,-sin(sine/20)/15,0) * angles(-sin(sine/20) * rad(1.5),sin(sine/80) * rad(5),sin(sine/40) * rad(1.5)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,sin(sine/20)/15,0) * angles(-cos(sine/20) * rad(7.5),sin(sine/80) * rad(5),sin(sine/40) * rad(2.5)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,(sin(sine/20)/15) + (sin(sine/40)/25),0) * angles((sin(sine/20) * rad(3.5)) + (sin(sine/80) * rad(2.5)),rad(0),sin(sine/40) * rad(5)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,(sin(sine/20)/15) + (-sin(sine/40)/25),0) * angles((sin(sine/20) * rad(3.5)) - (sin(sine/80) * rad(2.5)),rad(0),sin(sine/40) * rad(5)),.1)
	elseif anim == "fall" and not hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
	elseif anim == "jump" and not hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.1)
	elseif anim == "walk" and hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(-sin(sine/1.75) * rad(1),sin(sine/3.5) * rad(3.5),sin(sine/3.5) * rad(2.5)) * angles(0,rotrl/1.5,0),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,sin(sine/1.75)/7.5,0) * angles(sin(sine/1.75) * rad(5),sin(sine/3.5) * rad(5),rad(0)) * angles(-rotfb/7.5,0,-rotrl/6),.2)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,sin(sine/1.75)/10,0) * angles(sin(sine/3.5) * rad(5) * rotfb,rad(0),rad(0)),.2)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,-sin(sine/1.75)/10,-cos(sine/3.5)/10) * angles(sin(sine/3.5) * rad(65) * rotfb,sin(sine/1.75) * rad(7.5),sin(sine/1.75) * rad(1.5)),.2)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,cos(sine/3.5)/5,-cos(sine/3.5)/3.5) * angles((sin(sine/3.5) * rad(60) + rad(7.5)) * rotfb,rad(0),sin(sine/3.5) * rad(45) * rotrl) * angles(rad(0),cos(sine/3.5) * rad(2.5),rad(0)),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,-cos(sine/3.5)/5,cos(sine/3.5)/3.5) * angles((-sin(sine/3.5) * rad(60) + rad(7.5)) * rotfb,rad(0),-sin(sine/3.5) * rad(45) * rotrl) * angles(rad(0),cos(sine/3.5) * rad(2.5),rad(0)),.2)
	end
	if not using then
		handleWeld.C0 = handleWeld.C0:Lerp(cf(0,-1,0) * angles(rad(-90),rad(0),rad(0)),.2)
		if horVel > 5 and verVel >-10 and verVel <10 then
			anim = "walk"
			change = .6
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(.15,-.75,-.25) * angles(rad(175),rad(65),rad(0)) * angles(rad(10),rad(0),rad(0)),.1)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(0),rad(0),rad(0)),.2)
		elseif verVel >10 then
			anim = "jump"
			change = 1
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(15),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(-5),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(.15,-.75,-.25) * angles(rad(175),rad(65),rad(0)) * angles(rad(10),rad(0),rad(0)),.1)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(rad(145),rad(0),rad(-8)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.1,-.1) * angles(rad(-3.5),rad(0),rad(2)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.3,-.25) * angles(rad(-9),rad(0),rad(-3.5)),.2)
		elseif verVel <-10 then
			anim = "fall"
			change = 1
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-5),rad(0),rad(0)),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(rad(5),rad(0),rad(0)),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(.15,-.75,-.25) * angles(rad(175),rad(65),rad(0)) * angles(rad(10),rad(0),rad(0)),.1)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(-.45,-.44,0) * angles(rad(6),rad(0),rad(-97.5)),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.3,-.25) * angles(rad(-9),rad(0),rad(2)),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.1,-.1) * angles(rad(-3.5),rad(0),rad(-3.5)),.2)
		elseif horVel < 5 and verVel >-10 and verVel <10 then
			anim = "idle"
			change = 1
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(rad(-10),rad(0),rad(0)),.1)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,-.05) * angles(rad(-5),rad(0),rad(0)),.1)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(.15,-.75,-.25) * angles(rad(175),rad(65),rad(0)) * angles(rad(10),rad(0),rad(0)),.1)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.15,.1) * angles(rad(-6.5),rad(15),rad(-3.5)),.1)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(rad(-5),rad(-5),rad(2.5)),.1)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(rad(-5),rad(5),rad(-2.5)),.1)
		end
	end
end)
    print("Clicked")
end)

Section:NewButton("VoidBoss", "FE VoidBoss", function(game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["PlaneModel"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["PogoStick"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["RunningBull"].Handle.Mesh:Destroy() --Metashard

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Arm", "Left Arm"}) do
    local arm = c[v]
    arm.Parent = nil
    arm.Transparency = 1
    arm.Parent = c
end

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Leg", "Left Leg"}) do
    local Leg = c[v]
    Leg.Parent = nil
    Leg.Transparency = 1
    Leg.Parent = c
end

local v3_net, v3_808 = Vector3.new(8000, 12500, 8000), Vector3.new(8, 0, 8)
		local function getNetlessVelocity(realPartVelocity)
			local mag = realPartVelocity.Magnitude
			if mag > 1 then
				local unit = realPartVelocity.Unit
				if (unit.Y > 0.25) or (unit.Y < -0.75) then
					return unit * (25.1 / unit.Y)
				end
			end 
			return v3_net + realPartVelocity * v3_808
		end
		local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
       head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -100
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.73,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.73,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.73,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.73,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 40
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = handle
            end
       else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Accessory"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

--biggesthandle:BreakJoints()
--biggesthandle.Anchored = true

--for i, v in pairs(handle1:GetDescendants()) do
    --if v:IsA("AlignOrientation") then
        --v.Enabled = false
   --end
--end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
    fling = true
end)
mouse.Button1Up:Connect(function()
    fling = false
end)
local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            --handle1.RotVelocity = vel
        end
    end)
end
doForSignal(stepped, v3(100, 100, 100))
doForSignal(renderstepped, v3(100, 100, 100))
doForSignal(heartbeat, v3(20000, 20000, 20000)) --https://web.roblox.com/catalog/63690008/Pal-Hair

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

local hat2 = gp(cplayer, "VANS_Umbrella", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Head"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(0, 0, 0)

local hat2 = gp(cplayer, "PlaneModel", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "PogoStick", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(0, 0, 110)

local hat2 = gp(cplayer, "RunningBull", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Head"]
att2.Position = Vector3.new(-1, 0.3, -1.65)
att2.Rotation = Vector3.new(90, -0, 0)  --HandleAccessory

local hat2 = gp(cplayer, "Metashard", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Head"]
att2.Position = Vector3.new(1, 0.3, -1.5)
att2.Rotation = Vector3.new(0, -0, 0)--HandleAccessory



FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()

local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
local mouse = Player:GetMouse()
local Create = FELOADLIBRARY.Create




local TweenService = game:GetService("TweenService")


--MaskTextureId = 124337542 --124337542 2340547251


owner=game:GetService("Players").LocalPlayer
Player = game:GetService("Players").LocalPlayer
script.Parent = Player.PlayerGui
ZTfade=false 
ZT=false

while Player.Character == nil do wait()
	
end
	

Character= Player.Character
Torso = Character.Torso
Head = Character.Head
Mouse = Player:GetMouse()
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
RootPart = Character["HumanoidRootPart"]
local Anim="Idle"
local inairvel=0
local WalkAnimStep = 0
local sine = 0
local change = 1
Animstep = 0
WalkAnimMove=0.1
Combo = 0
local attack=false
local RJ = Character.HumanoidRootPart:FindFirstChild("RootJoint")
local Neck = Character.Torso:FindFirstChild("Neck")
local Tim = ""
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14) 
local NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local ONeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
Effects=Instance.new("Folder",Character)
Effects.Name="Effects"
it=Instance.new
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
local cn = CFrame.new
mr=math.rad
mememode=false
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local lastid= "http://www.roblox.com/asset/?id=468582223"
local s2=it("Sound",Torso)
local CurId = 1
s2.EmitterSize = 30
local s2c=s2:Clone()

--1837768323 music


local crying = "http://www.roblox.com/asset/?id=1452402780"
local s3=it("Sound",Head)

s3.EmitterSize = 40
local s3c=s3:Clone()



Humanoid.MaxHealth = 99999999999
wait()

Humanoid.Health = 99999999999
Humanoid.Name = "VoidBoss"
ff = Instance.new("ForceField",Character)
ff.Visible = false
playsong = true

s2.SoundId = lastid
	if playsong == true then
	s2:play()		
	elseif playsong == false then
	s2:stop()			
	end
lastsongpos= 0

crosshair = Instance.new("BillboardGui",Character)
crosshair.Size = UDim2.new(10,0,10,0)
crosshair.Enabled = false
imgl = Instance.new("ImageLabel",crosshair)
imgl.Position = UDim2.new(0,0,0,0)
imgl.Size = UDim2.new(1,0,1,0)
imgl.Image = "rbxassetid://578065407"
imgl.BackgroundTransparency = 1
imgl.ImageTransparency = .7
imgl.ImageColor3 = Color3.new(1,1,1)
	crosshair.StudsOffset = Vector3.new(0,0,-1)


if Character:FindFirstChild("Animate")then
	Character.Animate:Destroy()
end

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end


	

	CFuncs = {
Part = {Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	
	local Part = Create("Part")({Parent = Parent, Reflectance = Reflectance, Transparency = Transparency, CanCollide = false, Locked = true, BrickColor = BrickColor.new(tostring(BColor)), Name = Name, Size = Size, Material = Material})
	RemoveOutlines(Part)
	return Part
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Weld = {Create = function(Parent, Part0, Part1, C0, C1)
	
	local Weld = Create("Weld")({Parent = Parent, Part0 = Part0, Part1 = Part1, C0 = C0, C1 = C1})
	return Weld
end
}
, 
Sound = {Create = function(id, par, vol, pit)
	
	coroutine.resume(coroutine.create(function()
		
		local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
		wait()
		S:play()
		game:GetService("Debris"):AddItem(S, 12)
	end
))
end
}
, 
ParticleEmitter = {Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
	
	local fp = Create("ParticleEmitter")({Parent = Parent, Color = ColorSequence.new(Color1, Color2), LightEmission = LightEmission, Size = Size, Texture = Texture, Transparency = Transparency, ZOffset = ZOffset, Acceleration = Accel, Drag = Drag, LockedToPart = LockedToPart, VelocityInheritance = VelocityInheritance, EmissionDirection = EmissionDirection, Enabled = Enabled, Lifetime = LifeTime, Rate = Rate, Rotation = Rotation, RotSpeed = RotSpeed, Speed = Speed, VelocitySpread = VelocitySpread})
	return fp
end
}
}





	coroutine.resume(coroutine.create(function()
		if Head:FindFirstChildOfClass("Decal") then
			local face = Head:FindFirstChildOfClass("Decal")
			--face:Destroy()
		end
		
	end))







	for i, v in pairs(Character:GetChildren()) do
		if v:IsA("Accessory") then
			v:Destroy()
		end
	end


---------------
--[Functions]--
---------------
so = function(id, par, vol, pit)

CFuncs.Sound.Create(id, par, vol, pit)


end

function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end


function MakeJoint(parent,part0,part1,c0)
local weld=it("Motor6D") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end

rayCast = function(Pos, Dir, Max, Ignore)
  
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return rayCast(StartPos, DIRECTION, Distance, Ignore)
end

function SetTween(SPart,CFr,MoveStyle2,outorin2,AnimTime)
local MoveStyle = Enum.EasingStyle[MoveStyle2]
local outorin = Enum.EasingDirection[outorin2]


local dahspeed=1

local tweeningInformation = TweenInfo.new(
	AnimTime/dahspeed,	
	MoveStyle,
	outorin,
	0,
	false,
	0
)
local MoveCF = CFr
local tweenanim = TweenService:Create(SPart,tweeningInformation,MoveCF)
tweenanim:Play()
end

function GatherAllInstances(Parent,ig)
	local Instances = {}
	local Ignore=nil
if	ig ~= nil then
Ignore = ig	
end
	
	local function GatherInstances(Parent,Ignore)
		for i, v in pairs(Parent:GetChildren()) do
			
			if v ~= Ignore then
				GatherInstances(v,Ignore)
			table.insert(Instances, v) end
		end
	end
	GatherInstances(Parent,Ignore)
	return Instances
end









function WeldAllTo(Part1,Part2,Extra)
	
local EXCF = Part2.CFrame * Extra	
	
for i, v3 in pairs(GatherAllInstances(Part2)) do
	if v3:isA("BasePart") then
		
		
local STW=weld(v3,v3,Part1,EXCF:toObjectSpace(v3.CFrame):inverse() )

	
					v3.Anchored=false
					--v3.Transparency=0
					v3.CanCollide=false	
					
v3.Parent = Part1					
					
					end
end


Part2:Destroy()

end
local SToneTexture = Create("Texture")({
	
	
	Texture = "http://www.roblox.com/asset/?id=1693385655",
    Color3 = Color3.new(163/255, 162/255, 165/255),
	
})

function AddStoneTexture(part)
	coroutine.resume(coroutine.create(function()
	for i = 0,6,1 do
local Tx = SToneTexture:Clone()
Tx.Face = i
Tx.Parent=part
end
	end))
end

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
function recurse(root,callback,i)
	coroutine.resume(coroutine.create(function()
	i= i or 0
	for _,v in pairs(root:GetChildren()) do
		i = i + 1
		callback(i,v)
		
		if #v:GetChildren() > 0 then
			i = recurse(v,callback,i)
		end
	end
	end))
	return i 
end

function ragdollJoint(part0, part1, attachmentName, className, properties)
	
	attachmentName = attachmentName--.."RigAttachment"

	
	local constraint = Instance.new(className.."Constraint")
	constraint.Attachment0 = part0:FindFirstChild(attachmentName)
	constraint.Attachment1 = part1:FindFirstChild(attachmentName)
	constraint.Name = "RagdollConstraint"..part1.Name
	
	for _,propertyData in next,properties or {} do
		constraint[propertyData[1]] = propertyData[2]
	end
	
	local Rcharacter = part0.Parent
	constraint.Parent = Rcharacter
end

function MakeAth(AthParent,AthName,AthPosX,AthPosY,AthPosZ,AthRot,AthAX,SecondaryAxis)
				
coroutine.resume(coroutine.create(function()
							local ATH = Instance.new("Attachment",AthParent)
						ATH.Position = Vector3.new(AthPosX,AthPosY,AthPosZ)
						ATH.Name = AthName
if AthRot ~= nil then					
ATH.Rotation = AthRot end
if AthAX ~= nil then
ATH.Axis = AthAX end
if SecondaryAxis ~= nil then
ATH.SecondaryAxis = SecondaryAxis end
end))
end
function getAttachment0(attachmentName,Rcharacter)
	for i, child in pairs(GatherAllInstances(Rcharacter)) do
		local attachment = child:FindFirstChild(attachmentName)
		if attachment then
			return attachment

			end

	end





end

	function makrag(Rcharacter)
	

--HitModel			


	local camera = workspace.CurrentCamera

	--Make it so ragdoll can't collide with invisible HRP, but don't let HRP fall through map and be destroyed in process	


for i = 0,2 do
coroutine.resume(coroutine.create(function()
	for _,child in next,Rcharacter:GetChildren() do
		if child:IsA("Accoutrement") then
			--Loop through all parts instead of only checking for one to be forwards-compatible in the event
			--ROBLOX implements multi-part accessories
			for _,part in next,child:GetChildren() do
				if part:IsA("BasePart") then part.CanCollide = false	
					

					local attachment1 = part:FindFirstChildOfClass("Attachment")
					local attachment0 = getAttachment0(attachment1.Name,Rcharacter)
					if attachment0 and attachment1 then
						--Shouldn't use constraints for this, but have to because of a ROBLOX idiosyncrasy where
						--joints connecting a character are perpetually deleted while the character is dead

				
	local HatProperties = {
		{"LimitsEnabled", true};
		{"UpperAngle", 0};
		{"LowerAngle", -0};
	}

				coroutine.resume(coroutine.create(function()
	wait()			
local rg = 	ragdollJoint(attachment0.Parent, part, ""..attachment1.Name, "Hinge", HatProperties)						
end))						
						
					end
				end
			end
		end
	end
	
end))
wait(0.5)
end
	for _,v in pairs(Rcharacter:GetChildren()) do	
	if v:isA("Script")	or v:isA("LocalScript") then
		--v:Destroy()
	end
	end


	coroutine.resume(coroutine.create(function()	
wait(1)
	for _,v3 in pairs(game:GetService("Players"):GetChildren()) do	
		coroutine.resume(coroutine.create(function()	
		if v3:isA("Player") and v3.Character == 	Rcharacter then
			Rcharacter.Archivable=true
			--local ORcharacter = Rcharacter:Clone()
			 --Rcharacter2.Archivable=false 
			--Rcharacter3.Archivable=false 
			 ORcharacter.Parent = Rcharacter.Parent
			--local Rhum = ORcharacter:FindFirstChildOfClass("Humanoid")
			Rhum.PlatformStand = true
						Rhum.Health = Rhum.MaxHealth
--Rcharacter:Destroy()
wait()
Rhum.Health = 0
game:GetService("Debris"):AddItem(ORcharacter, 380)

		end
		end))
		end			


end))


			end


function Tran(Num)
local GivenLeter = ""
if Num == "1" then
GivenLeter = "a"	
elseif Num == "2" then
GivenLeter = "b"
elseif Num == "3" then
GivenLeter = "c"
elseif Num == "4" then
GivenLeter = "d"
elseif Num == "5" then
GivenLeter = "e"
elseif Num == "6" then
GivenLeter = "f"
elseif Num == "7" then
GivenLeter = "g"
elseif Num == "8" then
GivenLeter = "h"
elseif Num == "9" then
GivenLeter = "i"
elseif Num == "10" then
GivenLeter = "j"
elseif Num == "11" then
GivenLeter = "k"
elseif Num == "12" then
GivenLeter = "l"
elseif Num == "13" then
GivenLeter = "m"
elseif Num == "14" then
GivenLeter = "n"
elseif Num == "15" then
GivenLeter = "o"
elseif Num == "16" then
GivenLeter = "p"
elseif Num == "17" then
GivenLeter = "q"
elseif Num == "18" then
GivenLeter = "r"
elseif Num == "19" then
GivenLeter = "s"
elseif Num == "20" then
GivenLeter = "t"
elseif Num == "21" then
GivenLeter = "u"
elseif Num == "22" then
GivenLeter = "v"
elseif Num == "23" then
GivenLeter = "w"
elseif Num == "24" then
GivenLeter = "x"
elseif Num == "25" then
GivenLeter = "y"
elseif Num == "26" then
GivenLeter = "z"
elseif Num == "27" then
GivenLeter = "_"
elseif Num == "28" then
GivenLeter = "0"
elseif Num == "29" then
GivenLeter = "1"
elseif Num == "30" then
GivenLeter = "2"	
elseif Num == "31" then
GivenLeter = "3"
elseif Num == "32" then
GivenLeter = "4"
elseif Num == "33" then
GivenLeter = "5"
elseif Num == "34" then
GivenLeter = "6"
elseif Num == "35" then
GivenLeter = "7"
elseif Num == "36" then
GivenLeter = "8"
elseif Num == "37" then
GivenLeter = "9"
end
return GivenLeter
	
end

function MaybeOk(Mode,Extra)
local ReturningValue = ""
if Mode == 1 then
	
	

	--	v.C0 = CFrame.new(1,1,1)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
		
		--print(v.C0)
local GivenText	= ""	
local	msg = 	Extra
local Txt = ""
local FoundTime=0
local LastFound = 0
        delay(wait(0),function()
                for v3 = 1, #msg do
                    
if string.sub(msg,0+v3,v3) == ","	then

local TheN = string.sub(msg,LastFound,v3-1)


local NumTranslate = Tran(string.sub(msg,LastFound,v3-1))



FoundTime = FoundTime + 1


GivenText = GivenText..NumTranslate

LastFound=v3+1
Txt=""
end
    Txt=string.sub(msg,1,v3)		


       --    Gui.ExtentsOffset = Vector3.new(0,3,0)


      --  Gui.ExtentsOffset = Vector3.new(0,3,0)                    
wait()
 -- Gui.ExtentsOffset = Vector3.new(0,3,0)   
                end;		

	 	ReturningValue=GivenText
	      for v3 = 1, #Txt do
                        Txt=string.sub(msg,-1,v3)


             




   end;
             --   Gui:remove()
        end)	
	

elseif Mode == 2 then
	
print("fat")
end



while ReturningValue == "" do wait() end
return ReturningValue
	
end



----------------------
--[End Of Functions]--
----------------------






------------------
--[Sword]--
------------------




function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
ParticleEmitter2 = Instance.new("ParticleEmitter")
Model3 = Instance.new("Model")
Beam4 = Instance.new("Beam")  ------------------------------------------------------------------------------
Beam5 = Instance.new("Beam")
Beam6 = Instance.new("Beam")






Model7 = Instance.new("Model")
Part8 = Instance.new("Part")
ParticleEmitter9 = Instance.new("ParticleEmitter")
Part10 = Instance.new("Part")
SpecialMesh11 = Instance.new("SpecialMesh")
Part12 = Instance.new("Part")
SpecialMesh13 = Instance.new("SpecialMesh")
Model14 = Instance.new("Model")
Part15 = Instance.new("Part")
SpecialMesh16 = Instance.new("SpecialMesh")
Part17 = Instance.new("Part")
SpecialMesh18 = Instance.new("SpecialMesh")
Part19 = Instance.new("Part")
ParticleEmitter20 = Instance.new("ParticleEmitter")
Model21 = Instance.new("Model")
Part22 = Instance.new("Part")
SpecialMesh23 = Instance.new("SpecialMesh")
Part24 = Instance.new("Part")
SpecialMesh25 = Instance.new("SpecialMesh")
Part26 = Instance.new("Part")
SpecialMesh27 = Instance.new("SpecialMesh")
Part28 = Instance.new("Part")
SpecialMesh29 = Instance.new("SpecialMesh")
Part30 = Instance.new("Part")
SpecialMesh31 = Instance.new("SpecialMesh")
Part32 = Instance.new("Part")
SpecialMesh33 = Instance.new("SpecialMesh")
Decal34 = Instance.new("Decal")
Part35 = Instance.new("Part")
ParticleEmitter36 = Instance.new("ParticleEmitter")
Part37 = Instance.new("Part")

TAttachment = Instance.new("Attachment",Part1)
HAttachment2 = Instance.new("Attachment",Part35)
RAttachment3 = Instance.new("Attachment",Part8)
LAttachment4 = Instance.new("Attachment",Part19)

--TAttachment
--HAttachment2
--RAttachment3
--LAttachment4


--Part35,Part19,Part8
--Head,LeftArm,RightArm


SpecialMesh38 = Instance.new("SpecialMesh")
Model0.Name = "VoidBoss"
Model0.Parent = mas
Part1.Name = "Torso"
Part1.Parent = Model0
Part1.CFrame = CFrame.new(3.5, 0.0108870268, -65.510788, 2.08616257e-07, 0, -1, 0.999999881, 0, 2.08616257e-07, 0, -0.999999881, 0)
Part1.Orientation = Vector3.new(0, -90, 90)
Part1.Position = Vector3.new(3.5, 0.0108870268, -65.510788)
Part1.Rotation = Vector3.new(-90, -90, 0)
Part1.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part1.Transparency = 1
Part1.Size = Vector3.new(1, 1, 1)
Part1.Anchored = true
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.BrickColor = BrickColor.new("Institutional white")
Part1.CanCollide = false
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.brickColor = BrickColor.new("Institutional white")
Part1.FormFactor = Enum.FormFactor.Symmetric
Part1.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter2.Parent = Part1
ParticleEmitter2.Speed = NumberRange.new(6, 6)
ParticleEmitter2.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.299,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(0.499,Color3.new(0,0,0)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter2.LightInfluence = 1
ParticleEmitter2.Texture = "rbxassetid://258128463"
ParticleEmitter2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.2,0.86913582086563),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter2.ZOffset = 1
ParticleEmitter2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.3749998807907),NumberSequenceKeypoint.new(1,0.68749964237213)})
ParticleEmitter2.Acceleration = Vector3.new(1, 0, 0)
ParticleEmitter2.Drag = 3
ParticleEmitter2.Lifetime = NumberRange.new(2, 4)
ParticleEmitter2.LockedToPart = true
ParticleEmitter2.Rate = 50
ParticleEmitter2.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter2.SpreadAngle = Vector2.new(360, 0)
ParticleEmitter2.VelocitySpread = 360
Model3.Parent = Part1

--TAttachment
--HAttachment2
--RAttachment3
--LAttachment4


Beam4.Name = "RightArm"
Beam4.Parent = Model3
Beam4.Attachment0 = TAttachment
Beam4.Attachment1 = RAttachment3
Beam4.CurveSize0 = 10
Beam4.FaceCamera = true
Beam4.LightInfluence = 1
Beam4.Texture = "rbxassetid://130207880"
Beam4.TextureLength = 0.875
Beam4.TextureSpeed = 1
Beam4.Transparency = NumberSequence.new(.5,0)
Beam4.Width0 = 3
Beam4.Width1 = 3
Beam5.Name = "LeftArm"
Beam5.Parent = Model3
Beam5.Attachment0 = TAttachment
Beam5.Attachment1 = LAttachment4
Beam5.CurveSize0 = 10
Beam5.FaceCamera = true
Beam5.LightInfluence = 1
Beam5.Texture = "rbxassetid://130207880"
Beam5.TextureLength = 0.875
Beam5.TextureSpeed = 1
Beam5.Transparency = NumberSequence.new(.5,0)
Beam5.Width0 = 3
Beam5.Width1 = 3
Beam6.Name = "Head"
Beam6.Parent = Model3
Beam6.Attachment0 = TAttachment
Beam6.Attachment1 = HAttachment2
Beam6.FaceCamera = true
Beam6.LightInfluence = 1
Beam6.Segments = 1
Beam6.Texture = "rbxassetid://130207880"
Beam6.TextureSpeed = 1
Beam6.Transparency = NumberSequence.new(.5,0)
Beam6.Width0 = 3
Beam6.Width1 = 1.5
Model7.Name = "RightArm"
Model7.Parent = Model0
Part8.Name = "Particles"
Part8.Parent = Model7
Part8.CFrame = CFrame.new(-3, 3.62246037, -66.4395981, -1, 0, 0, 0, 0.999390841, 0.0348994173, 0, 0.0348994173, -0.999390841)
Part8.Orientation = Vector3.new(-2, 180, 0)
Part8.Position = Vector3.new(-3, 3.62246037, -66.4395981)
Part8.Rotation = Vector3.new(-178, 0, -180)
Part8.Color = Color3.new(0, 0, 0)
Part8.Transparency = 1
Part8.Size = Vector3.new(0.5, 0.5, 0.5)
Part8.Anchored = true
Part8.BottomSurface = Enum.SurfaceType.Smooth

Part8.CanCollide = false
Part8.Material = Enum.Material.Neon
Part8.TopSurface = Enum.SurfaceType.Smooth

Part8.FormFactor = Enum.FormFactor.Symmetric
Part8.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter9.Parent = Part8
ParticleEmitter9.Speed = NumberRange.new(1.2000000476837, 1.2000000476837)
ParticleEmitter9.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.699,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter9.LightInfluence = 1
ParticleEmitter9.Texture = "rbxassetid://258128463"
ParticleEmitter9.Transparency= NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0.7),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter9.ZOffset = 2
ParticleEmitter9.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.9999998807907),NumberSequenceKeypoint.new(0.43749988079071,0.37499964237213),NumberSequenceKeypoint.new(1,0.68749964237213)})  
ParticleEmitter9.Acceleration = Vector3.new(0, 0, -0.400000006)
ParticleEmitter9.Drag = 1
ParticleEmitter9.Lifetime = NumberRange.new(3, 3)
ParticleEmitter9.LockedToPart = true
ParticleEmitter9.Rate = 100
ParticleEmitter9.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter9.SpreadAngle = Vector2.new(360, 360)
ParticleEmitter9.VelocitySpread = 360
Part10.Parent = Model7
Part10.CFrame = CFrame.new(-2, 4.33036613, -62.6395836, -0.965925813, 0.0669872463, -0.25, 0, 0.965925872, 0.258818835, 0.258819044, 0.249999791, -0.933012724)
Part10.Orientation = Vector3.new(-15, -165, 0)
Part10.Position = Vector3.new(-2, 4.33036613, -62.6395836)
Part10.Rotation = Vector3.new(-164.5, -14.4799995, -176.029999)
Part10.Color = Color3.new(0, 0, 0)
Part10.Size = Vector3.new(1, 1, 0.5)
Part10.Anchored = true
Part10.BottomSurface = Enum.SurfaceType.Smooth

Part10.CanCollide = false
Part10.Material = Enum.Material.Neon
Part10.TopSurface = Enum.SurfaceType.Smooth

Part10.FormFactor = Enum.FormFactor.Symmetric
Part10.formFactor = Enum.FormFactor.Symmetric
SpecialMesh11.Parent = Part10
SpecialMesh11.MeshType = Enum.MeshType.Sphere
Part12.Parent = Model7
Part12.CFrame = CFrame.new(-1.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)
Part12.Position = Vector3.new(-1.5, 4.83036566, -63.1395836)
Part12.Color = Color3.new(0.792157, 0.796079, 0.819608)
Part12.Size = Vector3.new(1, 1, 1)
Part12.Anchored = true
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.BrickColor = BrickColor.new("Ghost grey")
Part12.CanCollide = false
Part12.Material = Enum.Material.Fabric
Part12.TopSurface = Enum.SurfaceType.Smooth
Part12.brickColor = BrickColor.new("Ghost grey")
Part12.FormFactor = Enum.FormFactor.Symmetric
Part12.formFactor = Enum.FormFactor.Symmetric
SpecialMesh13.Parent = Part12
SpecialMesh13.MeshId = "rbxassetid://1282322452"
SpecialMesh13.Scale = Vector3.new(0.600000024, 0.600000024, 0.600000024)
SpecialMesh13.MeshType = Enum.MeshType.FileMesh
Model14.Name = "LeftArm"
Model14.Parent = Model0
Part15.Parent = Model14
Part15.CFrame = CFrame.new(8.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)
Part15.Position = Vector3.new(8.5, 4.83036566, -63.1395836)
Part15.Color = Color3.new(0.792157, 0.796079, 0.819608)
Part15.Size = Vector3.new(1, 1, 1)
Part15.Anchored = true
Part15.BottomSurface = Enum.SurfaceType.Smooth
Part15.BrickColor = BrickColor.new("Ghost grey")
Part15.CanCollide = false
Part15.Material = Enum.Material.Fabric
Part15.TopSurface = Enum.SurfaceType.Smooth
Part15.brickColor = BrickColor.new("Ghost grey")
Part15.FormFactor = Enum.FormFactor.Symmetric
Part15.formFactor = Enum.FormFactor.Symmetric
SpecialMesh16.Parent = Part15
SpecialMesh16.MeshId = "rbxassetid://1279765257"
SpecialMesh16.Scale = Vector3.new(0.600000024, 0.600000024, 0.600000024)
SpecialMesh16.MeshType = Enum.MeshType.FileMesh
Part17.Parent = Model14
Part17.CFrame = CFrame.new(9, 4.33036613, -62.6395836, -0.965925872, -0.0669871867, 0.249999806, 0, 0.965925872, 0.258818835, -0.258818835, 0.249999806, -0.933012784)
Part17.Orientation = Vector3.new(-15, 165, 0)
Part17.Position = Vector3.new(9, 4.33036613, -62.6395836)
Part17.Rotation = Vector3.new(-164.5, 14.4799995, 176.029999)
Part17.Color = Color3.new(0, 0, 0)
Part17.Size = Vector3.new(1, 1, 0.5)
Part17.Anchored = true
Part17.BottomSurface = Enum.SurfaceType.Smooth

Part17.CanCollide = false
Part17.Material = Enum.Material.Neon
Part17.TopSurface = Enum.SurfaceType.Smooth

Part17.FormFactor = Enum.FormFactor.Symmetric
Part17.formFactor = Enum.FormFactor.Symmetric
SpecialMesh18.Parent = Part17
SpecialMesh18.MeshType = Enum.MeshType.Sphere
Part19.Name = "Particles"
Part19.Parent = Model14
Part19.CFrame = CFrame.new(10, 3.62246037, -66.4395981, -1, 0, 0, 0, 0.999390841, 0.0348994173, 0, 0.0348994173, -0.999390841)
Part19.Orientation = Vector3.new(-2, 180, 0)
Part19.Position = Vector3.new(10, 3.62246037, -66.4395981)
Part19.Rotation = Vector3.new(-178, 0, -180)
Part19.Color = Color3.new(0, 0, 0)
Part19.Transparency = 1
Part19.Size = Vector3.new(0.5, 0.5, 0.5)
Part19.Anchored = true
Part19.BottomSurface = Enum.SurfaceType.Smooth

Part19.CanCollide = false
Part19.Material = Enum.Material.Neon
Part19.TopSurface = Enum.SurfaceType.Smooth

Part19.FormFactor = Enum.FormFactor.Symmetric
Part19.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter20.Parent = Part19
ParticleEmitter20.Speed = NumberRange.new(1.2000000476837, 1.2000000476837)
ParticleEmitter20.Color =  ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.699,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter20.LightInfluence = 1
ParticleEmitter20.Texture = "rbxassetid://258128463"
ParticleEmitter20.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0.7),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter20.ZOffset = 2
ParticleEmitter20.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.9999998807907),NumberSequenceKeypoint.new(0.43749988079071,0.37499964237213),NumberSequenceKeypoint.new(1,0.68749964237213)})  
ParticleEmitter20.Acceleration = Vector3.new(0, 0, -0.400000006)
ParticleEmitter20.Drag = 1
ParticleEmitter20.Lifetime = NumberRange.new(3, 3)
ParticleEmitter20.LockedToPart = true
ParticleEmitter20.Rate = 100
ParticleEmitter20.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter20.SpreadAngle = Vector2.new(360, 360)
ParticleEmitter20.VelocitySpread = 360
Model21.Name = "Head"
Model21.Parent = Model0
Part22.Parent = Model21
Part22.CFrame = CFrame.new(4, 8.9408741, -63.4595413, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part22.Orientation = Vector3.new(-15, 180, 0)
Part22.Position = Vector3.new(4, 8.9408741, -63.4595413)
Part22.Rotation = Vector3.new(-165, 0, -180)
Part22.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part22.Size = Vector3.new(0.400000036, 0.400000036, 1.20000005)
Part22.Anchored = true
Part22.BottomSurface = Enum.SurfaceType.Smooth
Part22.BrickColor = BrickColor.new("Institutional white")
Part22.CanCollide = false
Part22.Locked = true
Part22.Material = Enum.Material.Neon
Part22.TopSurface = Enum.SurfaceType.Smooth
Part22.brickColor = BrickColor.new("Institutional white")
Part22.FormFactor = Enum.FormFactor.Symmetric
Part22.formFactor = Enum.FormFactor.Symmetric
Part22.Name = "Eye1"
SpecialMesh23.Parent = Part22
SpecialMesh23.MeshType = Enum.MeshType.Sphere
Part24.Parent = Model21
Part24.CFrame = CFrame.new(3.5, 8.93740559, -63.2534142, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part24.Orientation = Vector3.new(-15, 180, 0)
Part24.Position = Vector3.new(3.5, 8.93740559, -63.2534142)
Part24.Rotation = Vector3.new(-165, 0, -180)
Part24.Color = Color3.new(0, 0, 0)
Part24.Size = Vector3.new(2, 1, 0.800000012)
Part24.Anchored = true
Part24.BottomSurface = Enum.SurfaceType.Smooth

Part24.CanCollide = false
Part24.Locked = true
Part24.Material = Enum.Material.Neon
Part24.TopSurface = Enum.SurfaceType.Smooth

Part24.FormFactor = Enum.FormFactor.Symmetric
Part24.formFactor = Enum.FormFactor.Symmetric
SpecialMesh25.Parent = Part24
SpecialMesh25.MeshType = Enum.MeshType.Sphere
Part26.Parent = Model21
Part26.CFrame = CFrame.new(3.5, 7.62994099, -63.3966942, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part26.Orientation = Vector3.new(-15, 180, 0)
Part26.Position = Vector3.new(3.5, 7.62994099, -63.3966942)
Part26.Rotation = Vector3.new(-165, 0, -180)
Part26.Color = Color3.new(0, 0, 0)
Part26.Size = Vector3.new(1.80000007, 1.5999999, 0.600000024)
Part26.Anchored = true
Part26.BottomSurface = Enum.SurfaceType.Smooth

Part26.CanCollide = false
Part26.Locked = true
Part26.Material = Enum.Material.Neon
Part26.TopSurface = Enum.SurfaceType.Smooth

Part26.FormFactor = Enum.FormFactor.Symmetric
Part26.formFactor = Enum.FormFactor.Symmetric
SpecialMesh27.Parent = Part26
SpecialMesh27.MeshType = Enum.MeshType.Sphere
Part28.Parent = Model21
Part28.CFrame = CFrame.new(3, 8.9408741, -63.4595413, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part28.Orientation = Vector3.new(-15, 180, 0)
Part28.Position = Vector3.new(3, 8.9408741, -63.4595413)
Part28.Rotation = Vector3.new(-165, 0, -180)
Part28.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part28.Size = Vector3.new(0.400000036, 0.400000036, 1.20000005)
Part28.Anchored = true
Part28.BottomSurface = Enum.SurfaceType.Smooth
Part28.BrickColor = BrickColor.new("Institutional white")
Part28.CanCollide = false
Part28.Locked = true
Part28.Material = Enum.Material.Neon
Part28.TopSurface = Enum.SurfaceType.Smooth
Part28.brickColor = BrickColor.new("Institutional white")
Part28.FormFactor = Enum.FormFactor.Symmetric
Part28.formFactor = Enum.FormFactor.Symmetric
Part28.Name = "Eye2"
SpecialMesh29.Parent = Part28
SpecialMesh29.MeshType = Enum.MeshType.Sphere
Part30.Parent = Model21
Part30.CFrame = CFrame.new(3.5, 8.98917007, -63.4466019, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part30.Orientation = Vector3.new(-15, 180, 0)
Part30.Position = Vector3.new(3.5, 8.98917007, -63.4466019)
Part30.Rotation = Vector3.new(-165, 0, -180)
Part30.Color = Color3.new(0, 0, 0)
Part30.Size = Vector3.new(1, 1, 1)
Part30.Anchored = true
Part30.BottomSurface = Enum.SurfaceType.Smooth

Part30.CanCollide = false
Part30.Locked = true
Part30.Material = Enum.Material.Neon
Part30.TopSurface = Enum.SurfaceType.Smooth

Part30.FormFactor = Enum.FormFactor.Symmetric
Part30.formFactor = Enum.FormFactor.Symmetric
SpecialMesh31.Parent = Part30
SpecialMesh31.MeshType = Enum.MeshType.Sphere
Part32.Name = "Handle"
Part32.Parent = Model21
Part32.CFrame = CFrame.new(3.5, 8.19017696, -63.2465782, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part32.Orientation = Vector3.new(-15, 180, 0)
Part32.Position = Vector3.new(3.5, 8.19017696, -63.2465782)
Part32.Rotation = Vector3.new(-165, 0, -180)
Part32.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part32.Size = Vector3.new(0.100000001, 0.100000001, 0.100000001)
Part32.Anchored = true
Part32.BottomSurface = Enum.SurfaceType.Smooth
Part32.BrickColor = BrickColor.new("Really black")
Part32.CanCollide = false
Part32.Locked = true
Part32.Material = Enum.Material.Fabric
Part32.TopSurface = Enum.SurfaceType.Smooth
Part32.brickColor = BrickColor.new("Really black")
Part32.FormFactor = Enum.FormFactor.Symmetric
Part32.formFactor = Enum.FormFactor.Symmetric
SpecialMesh33.Parent = Part32
SpecialMesh33.MeshId = "http://www.roblox.com/asset/?id=13520257"
SpecialMesh33.Scale = Vector3.new(3, 3.0999999, 3)
SpecialMesh33.MeshType = Enum.MeshType.FileMesh
SpecialMesh33.TextureId = "http://www.roblox.com/asset/?id=2349706532"
Decal34.Parent = Part32
--Decal34.Texture = "http://www.roblox.com/asset/?id="..MaskTextureId--124337542 2340547251
Part35.Name = "Particles"
Part35.Parent = Model21
Part35.CFrame = CFrame.new(3.5, 8.64255619, -64.4712448, -1, 0, 0, 0, 0.956304669, 0.292371869, 0, 0.292371869, -0.956304669)
Part35.Orientation = Vector3.new(-17, 180, 0)
Part35.Position = Vector3.new(3.5, 8.64255619, -64.4712448)
Part35.Rotation = Vector3.new(-163, 0, -180)
Part35.Color = Color3.new(0, 0, 0)
Part35.Transparency = 1
Part35.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part35.Anchored = true
Part35.BottomSurface = Enum.SurfaceType.Smooth

Part35.CanCollide = false
Part35.Locked = true
Part35.Material = Enum.Material.Neon
Part35.TopSurface = Enum.SurfaceType.Smooth

Part35.FormFactor = Enum.FormFactor.Symmetric
Part35.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter36.Parent = Part35
ParticleEmitter36.Speed = NumberRange.new(2, 2)
ParticleEmitter36.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.699,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter36.LightInfluence = 1
ParticleEmitter36.Texture = "rbxassetid://258128463"
ParticleEmitter36.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0.5),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter36.ZOffset = -2
ParticleEmitter36.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.7500001192093),NumberSequenceKeypoint.new(0.7500001192093,0.74999988079071),NumberSequenceKeypoint.new(1,0.68749964237213)})
ParticleEmitter36.Acceleration = Vector3.new(0, 0.25, 0)
ParticleEmitter36.Drag = 2
ParticleEmitter36.Lifetime = NumberRange.new(1, 3)
ParticleEmitter36.LockedToPart = true
ParticleEmitter36.Rate = 100.01999664307
ParticleEmitter36.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter36.SpreadAngle = Vector2.new(360, 360)
ParticleEmitter36.VelocitySpread = 360
Part37.Name = "Head"
Part37.Parent = Model21
Part37.CFrame = CFrame.new(3.5, 8.64255619, -64.4712448, -1, 0, 0, 0, 0.956304669, 0.292371869, 0, 0.292371869, -0.956304669)
Part37.Orientation = Vector3.new(-17, 180, 0)
Part37.Position = Vector3.new(3.5, 8.64255619, -64.4712448)
Part37.Rotation = Vector3.new(-163, 0, -180)
Part37.Color = Color3.new(0.00784314, 0.00784314, 0.00784314)
Part37.Size = Vector3.new(3, 3, 3)
Part37.Anchored = true
Part37.BottomSurface = Enum.SurfaceType.Smooth

Part37.CanCollide = false
Part37.Locked = true
Part37.Material = Enum.Material.Fabric
Part37.TopSurface = Enum.SurfaceType.Smooth

Part37.FormFactor = Enum.FormFactor.Symmetric
Part37.formFactor = Enum.FormFactor.Symmetric
SpecialMesh38.Parent = Part37
for i,v in pairs(mas:GetChildren()) do
	v.Parent = script
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end

script:WaitForChild("VoidBoss")
script.VoidBoss:WaitForChild("LeftArm")
script.VoidBoss:WaitForChild("RightArm")
script.VoidBoss:WaitForChild("Head")
local LAP=Instance.new("Part")
		LAP.Reflectance = 0
		LAP.Transparency = 1
		LAP.CanCollide = false
		LAP.Locked = true
		LAP.Anchored=true
		LAP.BrickColor = BrickColor.new("Really blue")
		LAP.Name = "Left Leg"
		LAP.Size = Vector3.new()
		LAP.Material = "SmoothPlastic"
		LAP:BreakJoints()		
	--	LAP.Parent = Character		
		LAP.CFrame = CFrame.new(8.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)*angles(math.rad(90),0,math.rad(180))
for i,v in pairs(script.VoidBoss.LeftArm:GetChildren()) do
	v.Parent = LAP
end	
script.VoidBoss.LeftArm:Destroy()
	LAP.Parent = script.VoidBoss	
	
local RAP=Instance.new("Part")
		RAP.Reflectance = 0
		RAP.Transparency = 1
		RAP.CanCollide = false
		RAP.Locked = true
		RAP.Anchored=true
		RAP.BrickColor = BrickColor.new("Really blue")
		RAP.Name = "Right Leg"
		RAP.Size = Vector3.new()
		RAP.Material = "SmoothPlastic"
		RAP:BreakJoints()		
	--	RAP.Parent = Character		
		RAP.CFrame = CFrame.new(-1.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)*angles(math.rad(90),0,math.rad(180))
for i,v in pairs(script.VoidBoss.RightArm:GetChildren()) do
	v.Parent = RAP
end	
script.VoidBoss.RightArm:Destroy()
	RAP.Parent = script.VoidBoss	

local HHP=Instance.new("Part")
		HHP.Reflectance = 0
		HHP.Transparency = 1
		HHP.CanCollide = false
		HHP.Locked = true
		HHP.Anchored=true
		HHP.BrickColor = BrickColor.new("Really blue")
		HHP.Name = "Head"
		HHP.Size = Vector3.new()
		HHP.Material = "SmoothPlastic"
		HHP:BreakJoints()		
		
		HHP.CFrame = CFrame.new(3.5, 8.64255619, -64.4712448, -1, 0, 0, 0, 0.956304669, 0.292371869, 0, 0.292371869, -0.956304669)
for i,v in pairs(script.VoidBoss.Head:GetChildren()) do
	v.Parent = HHP
end	
script.VoidBoss.Head:Destroy()
	HHP.Parent = script.VoidBoss	


--[ ACTIVATE MODEL BY GETING RID OF THIS LINE
for i, v in pairs(GatherAllInstances(script.VoidBoss)) do
	if v:isA("BasePart") then
	RemoveOutlines(v)
	if v:FindFirstChildOfClass("SpecialMesh") and v:FindFirstChildOfClass("SpecialMesh").MeshId~=nil then
	--local mesh = v:FindChildOfClass("SpecialMesh")	
	--v.Size = v.Size/2
	
	
	end
	end
	end

for _,v in pairs(script.VoidBoss:children()) do
		if v:IsA("BasePart")  then
			
			if  Character:FindFirstChild(""..v.Name) then
				local Part1=Character:FindFirstChild(""..v.Name)
				local Part2=v
				
WeldAllTo(Part1,Part2,CFrame.new(0,0,0))

			end
			
			
		end
end	

--]]




for _,v in pairs(Character:children()) do
		if v:IsA("Accessory")  then
			--v:Destroy()
		elseif v:IsA("BasePart")  then	
			v.Transparency =1
		end
end


	
DGT= function()
local Tlifetime = 0.17
local DaggerTrail=Instance.new("Trail",Sword)	
local Attach1 = Instance.new("Attachment",Sword.HitBox)	
local Attach2 = Instance.new("Attachment",Sword.HitBox)	
Attach2.Position = Vector3.new(0,0,3)
Attach1.Position = Vector3.new(0,0,-3)       
DaggerTrail.Attachment0 = Attach1
DaggerTrail.Attachment1 = Attach2 
DaggerTrail.Texture = "rbxassetid://1251856844"
DaggerTrail.Lifetime = .1
DaggerTrail.MaxLength = 10
DaggerTrail.MinLength = 0
DaggerTrail.TextureMode= "Static"
DaggerTrail.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
DaggerTrail.WidthScale=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(1,0)})
DaggerTrail.LightEmission=0
DaggerTrail.Color = ColorSequence.new(Color3.new(0,1,0),Color3.new(0,1,0))
DaggerTrail.LightEmission = 1
game:GetService("Debris"):AddItem(DaggerTrail, Tlifetime)
game:GetService("Debris"):AddItem(Attach1, Tlifetime)
game:GetService("Debris"):AddItem(Attach2, Tlifetime)
end

function CreatePart( Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end

function CreateMesh2(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart2(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local S = IT("Sound")
function CreateSound2(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end


	function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local TweenNameType = (Table.TweenNType or "Linear" )
	local TweenInOutType = (Table.TweenOType or "InOut" )
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart2(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound2(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crown" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "173770780", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
			
				SetTween(EFFECT,{CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))},"Linear","InOut",TIME/60)
			else
		
			SetTween(EFFECT,{CFrame = CFRAME},"Linear","InOut",0)
				
			end
			
			
			
			wait()
			
			SetTween(EFFECT,{Transparency = EFFECT.Transparency - TRANS},"Linear","InOut",TIME/60)
			
							if TYPE == "Block" then
	
					SetTween(EFFECT,{CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))},"Linear","InOut",0)
				else

					SetTween(EFFECT,{CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))},"Linear","InOut",0)
					
				end
							if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation

					SetTween(EFFECT,{CFrame=CF(MOVEDIRECTION)},"Linear","InOut",TIME/60)
						SetTween(EFFECT,{Orientation=ORI},"Linear","InOut",TIME/60)
				
					
							end
							MSH.Scale = MSH.Scale - GROWTH/TIME
									SetTween(MSH,{Scale=ENDSIZE},TweenNameType,TweenInOutType,TIME/60)
										if TYPE == "Wave" then
				
						SetTween(MSH,{Offset=VT(0,0,-MSH.Scale.X/8)},TweenNameType,TweenInOutType,TIME/60)
				end
			for LOOP = 1, TIME+1 do
				wait(.05)

				--SetTween(EFFECT,{Transparency = EFFECT.Transparency - TRANS/TIME},"Linear","InOut",0)
				
				
				if TYPE == "Block" then
	
	--				SetTween(EFFECT,{CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))},"Linear","InOut",0)
				else

	--				SetTween(EFFECT,{CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))},"Linear","InOut",0)
					
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation

--					SetTween(EFFECT,{CFrame=CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)},"Linear","InOut",0)
--						SetTween(EFFECT,{Orientation=ORI},"Linear","InOut",0)
				
					
				end
			end
				game:GetService("Debris"):AddItem(EFFECT, 15)
				coroutine.resume(coroutine.create(function()
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
			end))
		else
			coroutine.resume(coroutine.create(function()
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat wait() until SOUND.Playing == false
				EFFECT:remove()
			end
			end))
		end
	end))
		end	
		
		
		
		
		
		
	Damagefunc = function(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	
	if hit.Parent == nil then
		return 
	end
	--local h = hit.Parent:FindFirstChild("Humanoid")
	for _,v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then

	h = v 
		
	end
	
end
	
	--gg
	
--local FoundTorso = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")	
		coroutine.resume(coroutine.create(function()	
if h.Health >9999999 and minim <9999 and Type~= "IgnoreType" and(h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")) and not h.Parent:FindFirstChild("Fly away")then
	
	
	local FATag = Instance.new("Model",h.Parent)

	FATag.Name = "Fly away"
game:GetService("Debris"):AddItem(FATag, 2.5)	
	
	
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=true
		end
	end	

wait(.25)
	
if 	h.Parent:FindFirstChildOfClass("Body Colors")then
--h.Parent:FindFirstChildOfClass("Body Colors"):Destroy()
end


	local FoundTorso = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
	
	coroutine.resume(coroutine.create(function()	
		
		
local YourGone = Instance.new("Part")
		YourGone.Reflectance = 0
		YourGone.Transparency = 1
		YourGone.CanCollide = false
		YourGone.Locked = true
		YourGone.Anchored=true
		YourGone.BrickColor = BrickColor.new("Really blue")
		YourGone.Name = "YourGone"
		YourGone.Size = Vector3.new()
		YourGone.Material = "SmoothPlastic"
		YourGone:BreakJoints()
		YourGone.Parent = FoundTorso		
		YourGone.CFrame = FoundTorso.CFrame
				
	local NewParticle = Instance.new("ParticleEmitter")
NewParticle.Parent = YourGone
NewParticle.Acceleration =  Vector3.new(0,0,0)
NewParticle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10),NumberSequenceKeypoint.new(1,.0)})
NewParticle.Color = ColorSequence.new(Color3.new (1,0,0), Color3.new (1, 0, 0))
NewParticle.Lifetime = NumberRange.new(0.55,0.95)
NewParticle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.25,.0),NumberSequenceKeypoint.new(1,1)})
NewParticle.Speed = NumberRange.new(0,0.0)
NewParticle.ZOffset = 2
NewParticle.Texture = "rbxassetid://243660364"
NewParticle.RotSpeed = NumberRange.new(-0,0)
NewParticle.Rotation = NumberRange.new(-180,180)
NewParticle.Enabled = false
game:GetService("Debris"):AddItem(YourGone, 3)	
for i = 0,2,1 do
NewParticle:Emit(1)
so("1448044156", FoundTorso,2, 1)
h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(50,100)/1000)				
			
			
		end
		
		
		
	end	

	
	
wait(.2)	
end
wait(.1)	
NewParticle:Emit(3)
so("1448044156", FoundTorso,2, .8)
h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(100,200)/1000)				
			
			
		end
		
		
		
	end	

	
	
	
	end))
	



wait(.1)



	
	
	
	
	end
	
	
	end))
	if h ~= nil and hit.Parent ~= Character and hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
			return 
		end
		local c = Create("ObjectValue")({Name = "creator", Value = game:service("Players").basstracker1970, Parent = h})
		game:GetService("Debris"):AddItem(c, 0.5)
		if HitSound ~= nil and HitPitch ~= nil then
			so(HitSound, hit, 1, HitPitch)
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil and block.className == "IntValue" and block.Value > 0 then
			blocked = true
			block.Value = block.Value - 1
			print(block.Value)
		end
		lockon(h.Parent)
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 2.5, Color3.new(0,0,0))
		else
			h.Health = h.Health - Damage / 2
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 2.5, Color3.new(0,0,0))
			
		end

		if Type == "Knockdown" then
					local hum = h
		
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
		
		wait(.2)
		HHumanoid.PlatformStand = false
	end
			), hum)
			
			
			
			local FoundTorso = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,FoundTorso.Position).lookVector * knockback, Parent = hit})
			local rl = Create("BodyAngularVelocity")({P = 3000, maxTorque = Vector3.new(5000, 5000, 5000) * 50, angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), Parent = hit})
			game:GetService("Debris"):AddItem(bodvol, .2)
			game:GetService("Debris"):AddItem(rl, 0.2)



		elseif Type == "Knockdown2" then
					local hum = h
		
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
		
						
 Combo = 1			wait(.2)
		HHumanoid.PlatformStand = false
	end
), hum)
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,Property.Position).lookVector * knockback})
			local rl = Create("BodyAngularVelocity")({P = 3000, maxTorque = Vector3.new(5000, 5000, 5000) * 50, angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), Parent = hit})
			game:GetService("Debris"):AddItem(bodvol, 0.2)
			game:GetService("Debris"):AddItem(rl, 0.2)






							local bodyVelocity2 = Create("BodyVelocity")({velocity = Vector3.new(0, 60, 0), P = 5000, maxForce = Vector3.new(8000, 12000, 8000), Parent = RootPart})
							game:GetService("Debris"):AddItem(bodyVelocity2, 0.1)

		elseif Type == "Normal" then
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,Property.Position).lookVector * knockback})
					if knockback > 0 then
						
				local HTorso = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
						vp.Parent = HTorso
					end
					game:GetService("Debris"):AddItem(vp, 0.25)
					
					
					
					
					
					
					
					
					
					
					
					
					
		elseif Type== "Instakill" 	then
					coroutine.resume(coroutine.create(function()	
if  (h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")) and not h.Parent:FindFirstChild("Fly away")then
	
	
	local FATag = Instance.new("Model",h.Parent)

	FATag.Name = "Fly away"
game:GetService("Debris"):AddItem(FATag, 2.5)	
	
	
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=true
		end
	end	

wait(.25)
	
if 	h.Parent:FindFirstChildOfClass("Body Colors")then
--h.Parent:FindFirstChildOfClass("Body Colors"):Destroy()
end


	local FoundTorso = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
	
	coroutine.resume(coroutine.create(function()	
		
		
local YourGone = Instance.new("Part")
		YourGone.Reflectance = 0
		YourGone.Transparency = 1
		YourGone.CanCollide = false
		YourGone.Locked = true
		YourGone.Anchored=true
		YourGone.BrickColor = BrickColor.new("Really blue")
		YourGone.Name = "YourGone"
		YourGone.Size = Vector3.new()
		YourGone.Material = "SmoothPlastic"
		YourGone:BreakJoints()
		YourGone.Parent = FoundTorso		
		YourGone.CFrame = FoundTorso.CFrame
				
	local NewParticle = Instance.new("ParticleEmitter")
NewParticle.Parent = YourGone
NewParticle.Acceleration =  Vector3.new(0,0,0)
NewParticle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10),NumberSequenceKeypoint.new(1,.0)})
NewParticle.Color = ColorSequence.new(Color3.new (1,0,0), Color3.new (1, 0, 0))
NewParticle.Lifetime = NumberRange.new(0.55,0.95)
NewParticle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.25,.0),NumberSequenceKeypoint.new(1,1)})
NewParticle.Speed = NumberRange.new(0,0.0)
NewParticle.ZOffset = 2
NewParticle.Texture = "rbxassetid://243660364"
NewParticle.RotSpeed = NumberRange.new(-0,0)
NewParticle.Rotation = NumberRange.new(-180,180)
NewParticle.Enabled = false
game:GetService("Debris"):AddItem(YourGone, 3)	
for i = 0,2,1 do
NewParticle:Emit(1)
so("1448044156", FoundTorso,2, 1)
--h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(50,100)/1000)				
			
			
		end
		
		
		
	end	

	
	
wait(.2)	
end
wait(.1)	
NewParticle:Emit(3)
so("1448044156", FoundTorso,2, .8)
h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(100,200)/1000)				
			
			
		end
		
		
		
	end	

	
	
	
	end))
	



wait(.1)



	
	
	
	
	end
	
	
	end))
				
					
					
					
		elseif Type == "HPSteal" then
					Humanoid.Health = Humanoid.Health + Damage
								local hum = h
		
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
		
						
 Combo = 1			wait(.2)
		HHumanoid.PlatformStand = false
	end
), hum)
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,Property.Position).lookVector * knockback})
			local rl = Create("BodyAngularVelocity")({P = 3000, maxTorque = Vector3.new(5000, 5000, 5000) * 50, angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), Parent = hit})
			game:GetService("Debris"):AddItem(bodvol, 0.2)
			game:GetService("Debris"):AddItem(rl, 0.2)






							local bodyVelocity2 = Create("BodyVelocity")({velocity = Vector3.new(0, 60, 0), P = 5000, maxForce = Vector3.new(8000, 12000, 8000), Parent = RootPart})
							game:GetService("Debris"):AddItem(bodyVelocity2, 0.1)

			
					elseif Type == "Impale" then






	

CFuncs.Sound.Create("http://www.roblox.com/asset/?id=268249319", Spike, .8, 2)	
			hit.Parent.Humanoid.PlatformStand = true
			
		
		wait(1)
		hit.Parent.Humanoid.PlatformStand = false
		elseif Type == "IgnoreType" then
			

			
			
			
				elseif Type == "Up" then
							local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 20, 0), P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = hit})
							game:GetService("Debris"):AddItem(bodyVelocity, 0.1)
							local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 20, 0), P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = hit})
							game:GetService("Debris"):AddItem(bodyVelocity, .1)
				
				

		
			
			
			
						elseif Type == "Snare" then
									local bp = Create("BodyPosition")({P = 900, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(bp, 1)
			
						

							elseif Type == "Freeze2" then
											local BodPos = Create("BodyPosition")({P = 50000, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
											local BodGy = Create("BodyGyro")({maxTorque = Vector3.new(400000, 400000, 400000) * math.huge, P = 20000, Parent = hit.Parent.Torso, cframe = hit.Parent.Torso.CFrame})
											hit.Parent.Torso.Anchored = true
											coroutine.resume(coroutine.create(function(Part)
		
		wait(1.5)
		Part.Anchored = false
	end
), hit.Parent.Torso)
											game:GetService("Debris"):AddItem(BodPos, 3)
											game:GetService("Debris"):AddItem(BodGy, 3)
										end
											local debounce = Create("BoolValue")({Name = "DebounceHit", Parent = hit.Parent, Value = true})
											game:GetService("Debris"):AddItem(debounce, Delay)
											c = Instance.new("ObjectValue")
											c.Name = "creator"
											c.Value = Player
											c.Parent = h
											game:GetService("Debris"):AddItem(c, 0.5)
										end
									end



	ShowDamage = function(Pos, Text, Time, Color)
	
	local Rate = 0.033333333333333
	if not Pos then
		local Pos = Vector3.new(0, 0, 0)
	end
	local Text = Text or ""
	local Time = Time or 2
	if not Color then
		local Color = Color3.new(1, 0, 1)
	end
	local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui")({Size = UDim2.new(2, 0, 2, 0), Adornee = EffectPart, Parent = EffectPart})
	local TextLabel = Create("TextLabel")({BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Text = "DMG: "..Text.."", TextColor3 = Color, TextScaled = true, Font = Enum.Font.ArialBold, Parent = BillboardGui})
	game.Debris:AddItem(EffectPart, Time + 0.1)
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		
		local Frames = Time / Rate
		
		
		
print(Frames)
		TextLabel.TextTransparency=0
		EffectPart.CFrame=CFrame.new(Pos)
		wait()
		SetTween(TextLabel,{TextTransparency=1},"Quad","In",Frames/60)
		SetTween(TextLabel,{Rotation=math.random(-25,25)},"Elastic","InOut",Frames/60)
		SetTween(TextLabel,{TextColor3=Color3.new(.15,0,.5)},"Elastic","InOut",Frames/60)

SetTween(EffectPart,{CFrame = CFrame.new(Pos) + Vector3.new(math.random(-5,5), math.random(1,5), math.random(-5,5))},"Linear","InOut",Frames/60)


		wait(Frames/60)
		
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end
)
end

	MagniDamage = function(Part, magni, mindam, maxdam, knock, Type2)
		
		
		
		
local Type=""




if  mememode == true then
 
Type=	"Instakill"

else
Type=Type2
end 
if Type2 == "NormalKnockdown" then
	Type= "Knockdown"
end
		
	for _,c in pairs(workspace:children()) do
		
		
		
		
		
		local hum = c:FindFirstChild("Humanoid")
	for _,v in pairs(c:children()) do
		if v:IsA("Humanoid") then
			hum = v
		end
	end	
		
		
		
		
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= magni and c.Name ~= Player.Name then
					Damagefunc(Part, head, mindam, maxdam, knock, Type, RootPart, 0.1, "851453784", 1.2)
				end
			end
		end
	end
end


function CFMagniDamage(HTCF,magni, mindam, maxdam, knock, Type)
local DGP = Instance.new("Part")

DGP.Parent = Character
DGP.Size = Vector3.new(0.05, 0.05, 0.05)
DGP.Transparency = 1
DGP.CanCollide = false
DGP.Anchored = true
RemoveOutlines(DGP)
DGP.Position=DGP.Position + Vector3.new(0,-.1,0)
DGP.CFrame = HTCF

coroutine.resume(coroutine.create(function()
MagniDamage(DGP, magni, mindam, maxdam, knock, Type)
end))
game:GetService("Debris"):AddItem(DGP, .05)


DGP.Archivable = false
end

		
		
		
------------------
--[End of Sword]--
------------------

---------------
--[Particles]--
---------------


local Particle2_1 = Create("ParticleEmitter"){
Color = ColorSequence.new(Color3.new (1,1,1),  Color3.new (170/255, 255/255, 255/255)),
Transparency =  NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.75,.4),NumberSequenceKeypoint.new(1,1)}),
Size = NumberSequence.new({NumberSequenceKeypoint.new(0,.5),NumberSequenceKeypoint.new(1,.0)}),
Texture = "rbxassetid://241922778",
Lifetime = NumberRange.new(0.55,0.95),
Rate = 100,
VelocitySpread = 180,
Rotation = NumberRange.new(0),
RotSpeed = NumberRange.new(-200,200),
Speed = NumberRange.new(8.0),
LightEmission = 1,
LockedToPart = false,
Acceleration = Vector3.new(0, 0, 0),
EmissionDirection = "Top",
Drag = 4,
Enabled = false
}


local BEGONE_Particle = Create("ParticleEmitter"){
Color = ColorSequence.new(Color3.new (1,1,1), Color3.new (1, 1, 1)),
Transparency =  NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.1,0),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(0.5,.2),NumberSequenceKeypoint.new(1,1)}),
Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.15,1.5),NumberSequenceKeypoint.new(.75,1.5),NumberSequenceKeypoint.new(1,0)}),
Texture = "rbxassetid://936193661",
Lifetime = NumberRange.new(1.5),
Rate = 100,
VelocitySpread = 0,
Rotation = NumberRange.new(0),
RotSpeed = NumberRange.new(-10,10),
Speed = NumberRange.new(0),
LightEmission = .25,
LockedToPart = true,
Acceleration = Vector3.new(0, -0, 0),
EmissionDirection = "Top",
Drag = 4,
ZOffset = 1,
Enabled = false
}










local VoidEmitter = Create("ParticleEmitter"){
Speed = NumberRange.new(1, 1),
Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.699,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))}),
LightInfluence = 1,
Texture = "rbxassetid://258128463",
Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0.5),NumberSequenceKeypoint.new(1,1)}),
ZOffset = 2,
Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.7500001192093),NumberSequenceKeypoint.new(0.7500001192093,0.74999988079071),NumberSequenceKeypoint.new(1,0.68749964237213)}),
Acceleration = Vector3.new(0, 0.25, 0),
Drag = 2,
Lifetime = NumberRange.new(1, 2),
LockedToPart = false,
Rate = 50.01999664307,
RotSpeed = NumberRange.new(-100, 100),
SpreadAngle = Vector2.new(360, 360),
VelocitySpread = 360,
Enabled = false
}






----------------------
--[End Of Particles]--
----------------------




-----------------

function lockon_OnOff ()
	coroutine.resume(coroutine.create(function()
		
		local NewParticleH = Instance.new("Attachment",eye)
		NewParticleH.Position = Vector3.new(0,0,.25)
			coroutine.resume(coroutine.create(function()
			local CrystalMainColor = Color3.new(0,1,0)	
		
		
		local NewParticle = Particle2_1:Clone()
NewParticle.Parent = NewParticleH
NewParticle.Enabled = true
NewParticle.Texture = "rbxassetid://68942583"
NewParticle.Acceleration =  Vector3.new(0,0,0)
NewParticle.Speed = NumberRange.new(0)
NewParticle.LockedToPart = true
NewParticle.ZOffset = .25
NewParticle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2.5),NumberSequenceKeypoint.new(1,0)})
NewParticle.Rate = 50
NewParticle.Color = ColorSequence.new(CrystalMainColor, CrystalMainColor)
NewParticle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(1,.9)})
NewParticle.Name = "XEF"		
		
		
	end))	
		
		
while ZT == true do 
	
	
	
	SetTween(imgl,{Rotation=imgl.Rotation+25.5},"Elastic","Out",3)
	if ZTfade==true then
	SetTween(imgl,{ImageTransparency=.7},"Elastic","Out",3)
	SetTween(crosshair,{Size = UDim2.new(10,0,10,0)},"Elastic","Out",1.5)
end


wait(1.5)	
	if ZTfade==true then
SetTween(imgl,{ImageTransparency=0},"Linear","InOut",0)
SetTween(crosshair,{Size = UDim2.new(11,0,11,0)},"Elastic","InOut",0)
end
wait()
end

	crosshair.Adornee = nil
	crosshair.Enabled = false
NewParticleH:Destroy()

end))
	end

--function lockon (targetted)
	if ZT == true then
	
		coroutine.resume(coroutine.create(function()
	--crosshair.Adornee = targetted:FindFirstChild("Torso") or targetted:FindFirstChild("UpperTorso")
	--crosshair.Enabled = true
	
ZTfade = false
SetTween(imgl,{ImageTransparency=1},"Linear","InOut",0)

SetTween(crosshair,{Size = UDim2.new(40,0,40,0)},"Linear","InOut",0)

wait()

SetTween(imgl,{ImageTransparency=.7},"Bounce","Out",2)

SetTween(crosshair,{Size = UDim2.new(10,0,10,0)},"Elastic","InOut",1)
wait(1)
ZTfade = true
		end))
		end
--end






-----------------


	


--[[
		for i, v in pairs(C:GetChildren()) do
if v:IsA("Accessory")then
v:Destroy()	
end
if v:IsA("BasePart")then
v.Transparency =1
if v.Name == "Head" then
	v:FindFirstChildOfClass("Decal"):Destroy()
end
end
		end--]]
--[[













local tweeningInformation = TweenInfo.new(
	0.5,	
	Enum.EasingStyle.Back,
	Enum.EasingDirection.Out,
	0,
	false,
	0
)
--]]


local RJW=weld(RJ.Parent,RJ.Part0,RJ.Part1,RJ.C0)
RJW.C1 = RJ.C1
RJW.Name = RJ.Name

local NeckW=weld(Neck.Parent,Neck.Part0,Neck.Part1,Neck.C0)
NeckW.C1 = Neck.C1
NeckW.Name = Neck.Name


--print(WRJ.Parent.Name)

local RW=weld(Torso,Torso,RightArm,cf(0,0,0))

local LW=weld(Torso,Torso,LeftArm,cf(0,0,0))

local RH=weld(Torso,RightArm,RightLeg,cf(0,0,0))

local LH=weld(Torso,LeftArm,LeftLeg,cf(0,0,0))



RW.C1 = cn(0, 0.5, 0)
LW.C1 = cn(0, 0.5, 0)
RH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
LH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))






--------
--(#Torso)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)},"Quad","InOut",0.1)
--------
--(#Head)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,0)},"Quad","InOut",0.1)
--------
--(#Right Arm)
SetTween(RW,{C0=CFrame.new(1.5 , 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Left Arm)
SetTween(LW,{C0=CFrame.new(-1.5, 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Right Leg)
SetTween(RH,{C0=CFrame.new(0, -0.90, 0)},"Quad","InOut",0.1)
--------
--(#Left Leg)
SetTween(LH,{C0=CFrame.new(0, -0.90, 0)},"Quad","InOut",0.1)



--[[
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(30))},"Quad","Out",0.1)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-30))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
--]]

function Attack1()
attack = true
SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(30))},"Quad","InOut",1)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-30))},"Quad","InOut",1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(-90))},"Quad","InOut",1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(90))},"Quad","InOut",1)


wait(1)

	WACKYEFFECT({Time = 10, EffectType = "Slash", Size = (VT(60,0,60)), Size2 = (VT(0,0,0)), Transparency = 1, Transparency2 = .5, CFrame = RootPart.CFrame * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 454850461, SoundPitch = 1, SoundVolume = 8})
						
						for i = 10, 60,10 do
							WACKYEFFECT({Time = 10+i, EffectType = "Slash", Size = (VT(60,0,60)), Size2 = (VT(0,0,0)), Transparency = 1, Transparency2 = .5, CFrame = RootPart.CFrame * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
						end					
for i = 0,10 do wait() wait() wait()
				local AREA = RootPart.CFrame * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0))*CF(0,0,MRANDOM(2,20))
			local TIMER = MRANDOM(30,50)/4
			WACKYEFFECT({Time = TIMER, EffectType = "Sphere", Size = VT(5,0,5)/1.1, Size2 = VT(0,15,0)/1.1, Transparency = .9, Transparency2 = 0, CFrame = AREA, MoveToPos = AREA.p+VT(0,MRANDOM(35,60),0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(.5,0,1), SoundID = nil, SoundPitch = 0.8, SoundVolume = 5})
			WACKYEFFECT({Time = TIMER, EffectType = "Sphere", Size = VT(5,0,5), Size2 = VT(0,15,0), Transparency = 0.9, Transparency2 = 0.5, CFrame = AREA, MoveToPos = AREA.p+VT(0,MRANDOM(35,60),0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 0.8, SoundVolume = 5})
			
end	
		if mememode == false then
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,3)*angles(math.rad(-40),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(30))},"Quad","InOut",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(-30))},"Quad","InOut",.4)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(-0))},"Quad","InOut",.4)

						for i = 10, 30,10 do
							WACKYEFFECT({Time = 20+i, EffectType = "Wave", Size = VT(5,0,5), Size2 = (VT(31,0,31)*7)/4.1, Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame*cn(0,5,0) * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
						end
						WACKYEFFECT({Time = 120, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(600,600,600), Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(.5,0,1), SoundID = 376976397, SoundPitch = .5, SoundVolume = 7})
						WACKYEFFECT({Time = 100, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(600,600,600), Transparency = 0, Transparency2 = 1, CFrame=RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = 1.5, SoundVolume = 10})
	WACKYEFFECT({Time = 120, EffectType = "Crown", Size = VT(0,0,0), Size2 = (VT(600,600,600)), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5,TweenNType="Quad",TweenOType="Out"})
						
CFMagniDamage(Head.CFrame,600,80,90,100,"Knockdown")



else






SetTween(RJW,{C0=RootCF*CFrame.new(0,0,3)*angles(math.rad(-40),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(30))},"Quad","InOut",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(-30))},"Quad","InOut",.4)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(-0))},"Quad","InOut",.4)


						WACKYEFFECT({Time = 120*2, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(1600,1600,1600), Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(.5,0,1), SoundID = 376976397, SoundPitch = .5, SoundVolume = 5})
						WACKYEFFECT({Time = 100*2, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(1600,1600,1600), Transparency = 0, Transparency2 = 1, CFrame=RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 132164034, SoundPitch = 1.2, SoundVolume = 10})
					for i = 10, 60,10 do
							WACKYEFFECT({Time = 20+i*2, EffectType = "Wave", Size = VT(5,0,5), Size2 = (VT(31,0,31)*7)/4.1, Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame*cn(0,5,0) * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		WACKYEFFECT({Time = 12*i, EffectType = "Crown", Size = VT(0,0,0), Size2 = (VT(1600,1600,1600)), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame , MoveToPos = nil, RotationX = 0, RotationY = math.random(-180,180), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5,TweenNType="Quad",TweenOType="Out"})
	
	CFMagniDamage(Head.CFrame,1600,80,90,100,"Knockdown")					
						wait(.05)
						end						










end

wait(1)





attack=false	
end


function Attack2()
attack = true

SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 2.5, -0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Back","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 2.5, -0)*angles(math.rad(-0),math.rad(0),math.rad(-30))},"Quad","InOut",.4)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(0),math.rad(0),math.rad(-0))},"Quad","InOut",.4)





wait(.3)


SetTween(RJW,{C0=RootCF*CFrame.new(0,-5,2)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(20),math.rad(40),math.rad(0))},"Quad","InOut",.2)
SetTween(RW,{C0=CFrame.new(3.5 , -4.5, -10)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(LW,{C0=CFrame.new(-3.5, 2.5, 2)*angles(math.rad(-30),math.rad(0),math.rad(-30))},"Quad","InOut",.2)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(-90),math.rad(-40),math.rad(20))},"Quad","InOut",.2)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(0),math.rad(0),math.rad(-0))},"Quad","InOut",.2)




	--	LAP.Parent = Character	
wait(.1)
local portal =Instance.new("Part")
		portal.Reflectance = 0
		portal.Transparency = 1
		portal.CanCollide = false
		portal.Locked = true
		portal.Anchored=true
		portal.BrickColor = BrickColor.new("Really blue")
		portal.Name = "portal"
		portal.Size = Vector3.new()
		portal.Material = "SmoothPlastic"
		portal:BreakJoints()	
		portal.CFrame = RootPart.CFrame*cn(4,0,-17)
		   local Portalfloor,PortalPos = rayCast(portal.Position, CFrame.new(portal.Position, portal.Position - Vector3.new(0, 1, 0)).lookVector, 80, Character)
portal.CFrame = cn(PortalPos)
			
						local max = 50
							local min = 6.5
							local light = min
							if mememode == true then	
							min = 0
							max = 100
							light = 3
							end		

	coroutine.resume(coroutine.create(function()
		WACKYEFFECT({Time = 120, EffectType = "Crown", Size = VT(0,0,0), Size2 = (VT(max+15,1,max+15)), Transparency = 0.9, Transparency2 = 1, CFrame = portal.CFrame , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5,TweenNType="Quad",TweenOType="Out"})
						WACKYEFFECT({Time = 240, EffectType = "Sphere", Size = VT(0,.1,0), Size2 = VT(light-.5,0.1,light-.5)*1.5, Transparency = 0, Transparency2 = 1, CFrame=portal.CFrame*cn(0,-0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 376976397, SoundPitch = 1, SoundVolume = 3,TweenNType="Back",TweenOType="Out"})
		wait(120/60)
		
		coroutine.resume(coroutine.create(function()
			wait(.1)
				for _,c in pairs(workspace:children()) do			
		
		
		

		
		
		
					
					local h = c:FindFirstChild("Humanoid")
	for _,v in pairs(c:children()) do
		if v:IsA("Humanoid") then
		if	v.Health > 0.0001 then
				h = v else  h = nil end
		end
	end
	
	local head = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
	
	if h ~= nil and head ~= nil then
				local targ = head.Position - portal.Position
							local mag = targ.magnitude

							
				if mag < max and mag > min  and c ~= Character then
			
print("Kill")
	coroutine.resume(coroutine.create(function()
--local Shade =Instance.new("Model",Effects)
--local hed =Instance.new("Part")
		--hed.Reflectance = 0
		--hed.Transparency = 1
		--hed.CanCollide = false
		--hed.Locked = true
		--hed.Anchored=false
		--hed.Color = Color3.new(0,0,0)
		--head.Material = "SmoothPlastic"
--local sTor=hed:Clone()
		--sTor.Name = "Torso2"
		--sTor.Size = Vector3.new(2,2,1)
		--sTor.Material = "SmoothPlastic"
		--sTor:BreakJoints()	
		--sTor.CFrame = portal.CFrame*cn(0,-10,0)
--local sraor=hed:Clone()
		--sraor.Name = "RightArm"
	    --sraor.Size = Vector3.new(1,2,1)
		--sraor.Material = "SmoothPlastic"
		--sraor:BreakJoints()	
		--sraor.CFrame = portal.CFrame*cn(0,-10,0)
--local slaor=sraor:Clone()
--slaor.Name = "LeftArm"
--local srlor=sraor:Clone() 
--srlor.Name = "RightLeg"
--local sllor=sraor:Clone() 
--sllor.Name = "LeftLeg"
		---hed.Name = "Head2"
		--hed.Size = Vector3.new(1,1,1)
		--hed.Material = "SmoothPlastic"
		--hed:BreakJoints()	
		--hed.CFrame = portal.CFrame*cn(0,-10,0)

 local Mesh =Instance.new("SpecialMesh",hed)

Mesh.Scale=Vector3.new(1.25,1.25,1.25)
coroutine.resume(coroutine.create(function()
local Eye = Instance.new("Part")
		Eye.Reflectance = 0
		Eye.Transparency = 0
		Eye.CanCollide = false
		Eye.Locked = true
		Eye.Anchored=false
		Eye.BrickColor = BrickColor.new("White")
		Eye.Name = "BEGONE"
		Eye.Size = Vector3.new(0.05,0.3,0.05)
		Eye.Material = "Neon"
		Eye:BreakJoints()
		Eye.Parent = Shade
 local EMesh =Instance.new("SpecialMesh",Eye)

EMesh.MeshType = "Sphere"
	



local Eye=weld(Eye,hed,Eye,cf(.18,.18,-.55))

end))
coroutine.resume(coroutine.create(function()
local Eye = Instance.new("Part")
		Eye.Reflectance = 0
		Eye.Transparency = 0
		Eye.CanCollide = false
		Eye.Locked = true
		Eye.Anchored=false
		Eye.BrickColor = BrickColor.new("White")
		Eye.Name = "BEGONE"
		Eye.Size = Vector3.new(.05,.3,.05)
		Eye.Material = "Neon"
		Eye:BreakJoints()
		Eye.Parent = Shade

		
 local EMesh =Instance.new("SpecialMesh",Eye)

EMesh.MeshType = "Sphere"


local Eye=weld(Eye,hed,Eye,cf(-.18,.18,-.55))

end))

sTor.Anchored = true
hed.Parent = Shade
sTor.Parent = Shade
sraor.Parent = Shade
slaor.Parent = Shade
srlor.Parent = Shade
sllor.Parent = Shade


SetTween(sTor,{Transparency=0},"Quad","InOut",1)
SetTween(hed,{Transparency=0},"Quad","InOut",1)
SetTween(sraor,{Transparency=0},"Quad","InOut",1)
SetTween(slaor,{Transparency=0},"Quad","InOut",1)
SetTween(srlor,{Transparency=0},"Quad","InOut",1)
SetTween(sllor,{Transparency=0},"Quad","InOut",1)





local NeckW2=MakeJoint(sTor,sTor,hed,CFrame.new(0,0,0))
NeckW2.C1 = NeckW.C1

--print(WRJ.Parent.Name)

local RW2=MakeJoint(sTor,sTor,sraor,cf(0,0,0))

local LW2=MakeJoint(sTor,sTor,slaor,cf(0,0,0))

local RH2=MakeJoint(sTor,sTor,srlor,cf(0,0,0))

local LH2=MakeJoint(sTor,sTor,sllor,cf(0,0,0))



RW2.C1 = cn(0, 0.5, 0)
LW2.C1 = cn(0, 0.5, 0)
RH2.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
LH2.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))




head.Anchored = true

--------
--(#Torso)
SetTween(sTor,{CFrame=cn(head.Position.x,portal.Position.y-5,head.Position.z)},"Quad","InOut", .1)
--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)},"Quad","InOut",0.1)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.5 , 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.5, 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Right Leg)
SetTween(RH2,{C0=CFrame.new(.5, -0.90, 0)},"Quad","InOut",0.1)
--------
--(#Left Leg)
SetTween(LH2,{C0=CFrame.new(-.5, -0.90, 0)},"Quad","InOut",0.1)


wait(.1)


--------
--(#Torso)
SetTween(sTor,{CFrame=head.CFrame*CFrame.new(0,0,2)},"Quad","InOut",1/2)
--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(-40),math.rad(0),math.rad(0))},"Quad","InOut",1/2)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.5 , 0.5, -.0)},"Quad","InOut",1/2)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.5, 0.5, -.0)},"Quad","InOut",1/2)

wait(1/2)
--------
--(#Torso)
SetTween(sTor,{CFrame=head.CFrame*CFrame.new(0,0,1)},"Quad","InOut",1/3)
--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(30),math.rad(0))},"Quad","InOut",1/3)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.5 , 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",1/3)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.5, 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",1/3)

wait(1/3)
--------
--local Grab=MakeJoint(sTor,sTor,head,cf(0,0,-1))
--head.Anchored = false
--(#Torso)

--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(30),math.rad(0))},"Quad","InOut",1/3)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.3 , 0.5, -.3)*angles(math.rad(90),math.rad(0),math.rad(-50))},"Quad","InOut",1/3)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.3, 0.5, -.3)*angles(math.rad(90),math.rad(0),math.rad(50))},"Quad","InOut",1/3)

wait(1/3)
		WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(1,16,1), Size2 = (VT(10,0,10)), Transparency = 0.2, Transparency2 = 1, CFrame = cn(head.Position.x,portal.Position.y,head.Position.z) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		
SetTween(sTor,{CFrame=cn(head.Position.x,portal.Position.y-5,head.Position.z)},"Quad","InOut", .2)

wait(.2)

Shade:Destroy()
coroutine.resume(coroutine.create(function()
c:BreakJoints()
end))
c.Parent = nil
h:Destroy()
c:Destroy()


end))

				end
				end
				end
		end))
		--CFMagniDamage(portal.CFrame,60,10,20,0,"Normal")

								WACKYEFFECT({Time = 160, EffectType = "Sphere", Size = VT(max+15,1,max+15)*1.5, Size2 = VT(0,.05,0), Transparency = 1, Transparency2 = 0, CFrame=portal.CFrame*cn(0,-0.025,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 424195979, SoundPitch = .5, SoundVolume = 4,TweenNType="Quad",TweenOType="InOut"})
		portal:Destroy()	
	end))




wait(.3)



attack=false	
end




--[[
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(30))},"Quad","Out",0.1)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-30))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
--]]



function AT1()
attack = true	


SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(-50),math.rad(40),math.rad(80))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(50),math.rad(-40),math.rad(-40))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(40),math.rad(-30),math.rad(-25))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-3.5, 5.5, -.0)*angles(math.rad(-78),math.rad(0),math.rad(-120))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(45),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",.3)	
wait(.3)	
	so("160773067", RootPart, 1.5, math.random(120,150)/100)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(-40))},"Quad","InOut",.15)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(40))},"Quad","InOut",.15)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(-0),math.rad(-50),math.rad(90))},"Quad","Out",.15)
SetTween(LW,{C0=CFrame.new(-3.5, 2.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-30))},"Quad","Out",.15)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)	
wait(.15/2)

CFMagniDamage(RootPart.CFrame*cn(4,0,-4),12.5,10,20,20,"HPSteal")

wait(.15/2)	




attack = false	
end


function AT2()
attack = true	
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(-50),math.rad(-40),math.rad(-80))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(50),math.rad(40),math.rad(40))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(3.5 , 5.5, -.0)*angles(math.rad(-78),math.rad(0),math.rad(120))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(40),math.rad(30),math.rad(25))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(-45),math.rad(0))},"Quad","InOut",.3)	
wait(.3)	
	so("160773067", RootPart, 1.5, math.random(120,150)/100)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(40))},"Quad","InOut",.15)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(-40))},"Quad","InOut",.15)
SetTween(RW,{C0=CFrame.new(3.5 , 2.5, -.0)*angles(math.rad(-0),math.rad(0),math.rad(30))},"Quad","Out",.15)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(0),math.rad(50),math.rad(-90))},"Quad","Out",.15)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)	
wait(.15/2)

CFMagniDamage(RootPart.CFrame*cn(-4,0,-4),12.5,10,20,50,"HPSteal")

wait(.15/2)	



	
attack = false	
end

function findNearestTorso(pos)
	local list = game.Workspace:children()
	local torso = nil
	local dist = 1000
	local temp = nil
	local human = nil
	local temp2 = nil
	for x = 1, #list do
		temp2 = list[x]
		if (temp2.className == "Model") and (temp2 ~= Character) then
			temp = (temp2:FindFirstChild("Torso") or temp2:FindFirstChild("UpperTorso"))
			human = temp2:FindFirstChildOfClass("Humanoid")
			if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
				if (temp.Position - pos).magnitude < dist then
					torso = temp
					dist = (temp.Position - pos).magnitude
				end
			end
		end
	end
	return torso
end

function Attack3()
attack = true	
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(-0))},"Quad","Out",.4)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)	
wait(.05)
		
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(3.5 , 3.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(80))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-3.5, 3.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-80))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(-90),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(90),math.rad(-0))},"Quad","InOut",.3)	
wait(.3)	
	so("260435136", RootPart, 2, .8)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,-5,2)*angles(math.rad(30),math.rad(-40),math.rad(0))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(6.0 , -2, -8)*angles(math.rad(85),math.rad(0),math.rad(-80))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-6.0, -2, -8)*angles(math.rad(90),math.rad(0),math.rad(80))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(-90),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(90),math.rad(-0))},"Quad","InOut",.3)	
wait(.3)

	
	  local TheGunHandle = Instance.new("Part")
		TheGunHandle.Reflectance = 0
		TheGunHandle.Transparency = 1
		TheGunHandle.CanCollide = false
		TheGunHandle.Locked = true
		TheGunHandle.Anchored=false
		TheGunHandle.BrickColor = BrickColor.new("Really blue")
		TheGunHandle.Name = "BHandle"
		TheGunHandle.Size = Vector3.new(2.5,1,2.5)
		TheGunHandle.Material = "SmoothPlastic"
		TheGunHandle:BreakJoints()
		TheGunHandle.Parent = workspace		
		TheGunHandle.CFrame = RootPart.CFrame	
		
		
		local SWeld=weld(TheGunHandle,RootPart,TheGunHandle,cf(0,0,-9)*angles(math.rad(0),math.rad(0),math.rad(0)))
		local IsHit = false
local function onTouch(HitPa)
	if IsHit == false then
		--local c = HitPa.Parent
				--local h = HitPa.Parent:FindFirstChild("Humanoid")
	for _,v in pairs(HitPa.Parent:children()) do
		if v:IsA("Humanoid") then
	
				h = v end
		
	end
		--local head = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
		--local realhead = c:FindFirstChild("Head")
	if h ~= nil and head ~= nil and realhead ~= nil then
	
	IsHit = true
	RootPart.Anchored=true
  SetTween(NeckW,{C0=NeckCF*CFrame.new(0,-5,2)*angles(math.rad(30),math.rad(40),math.rad(0))},"Quad","InOut",3)
			local SWeld=MakeJoint(head,Torso,head,cf(0,-1,-9)*angles(math.rad(180),math.rad(0),math.rad(180)))
			
	coroutine.resume(coroutine.create(function()		
local pem = VoidEmitter:Clone()		
pem.Enabled = true			
pem.Parent = realhead			
	so("2162238854", RootPart, 2, .5)
	wait(2.9)
		if mememode == false then
			wait(.1)
		end
	pem.Rate = 0	
	if mememode == true then
		coroutine.resume(coroutine.create(function()	
	
local	Dust = Instance.new("Model") 
local DustTorso = Instance.new("Part",Dust) 
local DustHead = Instance.new("Part",Dust) 
game:GetService("Debris"):AddItem(DustHead, 120)
DustHead.Name = "Head"
DustHead.Size = Vector3.new(realhead.Size.y,realhead.Size.y,realhead.Size.y)
RemoveOutlines(DustHead)
DustHead:BreakJoints()
DustHead.CFrame = CFrame.new(0,1000,0)		
DustHead.Transparency = 1
DustTorso.Name = "Torso"
DustTorso.Size = Vector3.new(realhead.Size.y,realhead.Size.y,realhead.Size.y)
RemoveOutlines(DustTorso)
DustTorso:BreakJoints()
DustTorso.CFrame = CFrame.new(0,1000,0)
DustTorso.Transparency = 1
Dust.Name = "DustMinion"










pem.Parent = DustHead
pem.Rate = 100

local DustWeld=weld(DustTorso,DustHead,DustTorso,cf(0,0,0))
DustTorso.CFrame = realhead.CFrame
wait(.2)
local DustHumanoid = Instance.new("Humanoid",Dust) 
DustHumanoid.MaxHealth = 40
DustHumanoid.Health = 40
DustHumanoid.WalkSpeed = 17
Dust.Parent = Effects
	
					so("438666001", DustTorso, 2, .8)
			
	
			coroutine.resume(coroutine.create(function()	
			local DustAlive = true	
		
			while DustAlive == true do 
			


if DustHumanoid.Health > 0.001 then



local FindNewTorso = findNearestTorso(DustTorso.Position)

if FindNewTorso ~= nil then
	
	DustHumanoid:MoveTo(FindNewTorso.Position)
	--print(DustHumanoid.Name)
local mag = 	(DustTorso.Position-FindNewTorso.Position).magnitude
if mag < 10 and FindNewTorso.Parent:FindFirstChildOfClass("Humanoid") and FindNewTorso.Parent:FindFirstChildOfClass("Humanoid").Health > 0.001 then


coroutine.resume(coroutine.create(function()
				
			coroutine.resume(coroutine.create(function()
	makrag(FindNewTorso.Parent)
	end))
	FindNewTorso.Parent:FindFirstChildOfClass("Humanoid").Health = 0
		FindNewTorso.Parent:BreakJoints()
if FindNewTorso.Parent:FindFirstChild("Head") then
pem.Parent = FindNewTorso.Parent.Head
pem:Emit(10)	
	so("215395388", DustTorso, 2, .8)
end
end))
DustHumanoid.Health = 0	
end	
	
else
	wait(2)
	DustHumanoid.Health = 0
end


end




			
			if DustHumanoid.Health < 0.001 then
					coroutine.resume(coroutine.create(function()
				pem.Rate = 0
					end))
					DustAlive = false
					game:GetService("Debris"):AddItem(Dust, 2)
	so("2162238854", DustTorso, 2, .8)
			end
			
			
			if Dust.Parent ~= Effects then
			coroutine.resume(coroutine.create(function()	
				Dust:Destroy()
			end))
			DustAlive = false	
			end
			
			
			
			
			
			wait(1)	
			end
			
			
			
			end))
	
	
	
	
	end))
	end
	end))
	
	
	
	wait(3)	
	coroutine.resume(coroutine.create(function()
		head.Velocity = RootPart.CFrame.lookVector * 1.2			
			coroutine.resume(coroutine.create(function()
	makrag(c)
	end))
	h.Health = 0
		c:BreakJoints()
RootPart.CFrame = Torso.CFrame*cn(0,-2,0)		
		RootPart.Anchored=false
end))
		attack = false
		
	end
	
	end	
	end		
TheGunHandle.Touched:connect(onTouch)	


wait(1)
coroutine.resume(coroutine.create(function()
	TheGunHandle:Destroy()
end))

if IsHit == false then	
attack = false
end		
end


function Attack4()
	attack=true
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.6)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.6)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(50))},"Back","Out",.6)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(-50))},"Back","Out",.6)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.6)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.6)	
wait(.6)	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 4.5, 4.0)*angles(math.rad(90),math.rad(0),math.rad(10))},"Quad","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 4.5, 4.0)*angles(math.rad(90),math.rad(0),math.rad(-10))},"Quad","Out",.4)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)	
wait(.4)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(60),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(30),math.rad(0),math.rad(-20))},"Back","Out",.2)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(30),math.rad(0),math.rad(20))},"Back","Out",.2)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
wait(.2)
	
local pilarsize= 1

if mememode == true then
	pilarsize= 3
end	






		WACKYEFFECT({Time = 30, EffectType = "Crown", Size = VT(9,0,9)*pilarsize, Size2 = (VT(10.5,110,10.5)*pilarsize), Transparency = 0.2, Transparency2 = 1, CFrame = RootPart.CFrame*cn(0,-3,-6)*angles(RAD(40),0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 357540482, SoundPitch = 1.8/(pilarsize/2), SoundVolume = 2*pilarsize})
			


coroutine.resume(coroutine.create(function()	
	wait(.1)
		local RPP = RootPart.Position + Vector3.new(0,5,0)
	local lookv= RootPart.CFrame.lookVector
	coroutine.resume(coroutine.create(function()
	for i = 1,10,1 do 
local attackP = RPP+lookv*i*(15*pilarsize)
local attackCF = CF(attackP,attackP+lookv*5)
			   local Portalfloor,PortalPos,test1 = rayCast(attackP, CFrame.new(attackP, attackP - Vector3.new(0, 1, 0)).lookVector, 80, Character)

local PortalPosCF = CF(PortalPos,PortalPos+test1)*ANGLES(RAD(-90+math.random(-10,10)),RAD(math.random(-360,360)),RAD(math.random(-10,10)))
	if PortalPosCF ~= nil then
	local Pillar = Instance.new("Part")
		Pillar.Reflectance = 0
		Pillar.Transparency = 0
		Pillar.CanCollide = true
		Pillar.Locked = true
		Pillar.Anchored=true
		Pillar.BrickColor = BrickColor.new("White")
		Pillar.Name = "Pillar"
		Pillar.Size = Vector3.new(8.108, 29.681, 8.108)*pilarsize
		Pillar.Material = "Concrete"
		Pillar:BreakJoints()
		Pillar.Parent = Effects
		Pillar.CFrame = PortalPosCF*cn(0,-30*pilarsize,0)
		local NewPillarMesh = Instance.new("SpecialMesh")
NewPillarMesh.Parent = Pillar
NewPillarMesh.MeshId = "http://www.roblox.com/asset/?id=2449719398"
NewPillarMesh.TextureId = "http://www.roblox.com/asset/?id=1693385655"
NewPillarMesh.Scale = Vector3.new(1,1,1)*pilarsize
NewPillarMesh.VertexColor = Vector3.new(23/255, 21/255, 29/255)
NewPillarMesh.MeshType = Enum.MeshType.FileMesh	
		
		SetTween(Pillar,{CFrame=PortalPosCF*cn(0,12*pilarsize,0)},"Quad","Out",.5)
		coroutine.resume(coroutine.create(function()
		wait(math.random(3,6))
		SetTween(Pillar,{CFrame=PortalPosCF*cn(0,-30*pilarsize,0)*ANGLES(RAD(math.random(-90,90)),RAD(math.random(-360,360)),RAD(math.random(-90,90)))},"Bounce","In",2)
			Pillar.CanCollide = false
			wait(1.5)
				CFMagniDamage(cn(PortalPos),18*pilarsize,20*pilarsize,30*pilarsize,50*pilarsize,"Knockdown")

						WACKYEFFECT({Time = 50, EffectType = "Crown", Size = VT(15,0,15)*pilarsize, Size2 = (VT(19,120,19)*pilarsize), Transparency = 0.6, Transparency2 = 1, CFrame = CF(PortalPos,PortalPos+test1)*ANGLES(RAD(-90),RAD(math.random(-360,360)),RAD(0)) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 1788899396, SoundPitch = 1/(pilarsize/2), SoundVolume = 3*pilarsize})
	
					SetTween(Pillar,{Transparency=1},"Quad","Out",2)
					wait(4)
			Pillar:Destroy()
		end))
		CFMagniDamage(cn(PortalPos),16*pilarsize,10*pilarsize,20*pilarsize,-20*pilarsize,"NormalKnockdown")

			WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(9,0,9)*pilarsize, Size2 = (VT(4.5,160,4.5)*pilarsize), Transparency = 0.2, Transparency2 = 1, CFrame = PortalPosCF, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 2175667385, SoundPitch = 0.8/(pilarsize/2), SoundVolume = 2*pilarsize})
			WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(4.5,40,4.5)*pilarsize, Size2 = (VT(30,0,30)*pilarsize), Transparency = 0.7, Transparency2 = 1, CFrame = CF(PortalPos,PortalPos+test1)*ANGLES(RAD(-90),RAD(math.random(-360,360)),RAD(0)) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 3})
	
	end
	
	wait(.05)
	end
	end))
	
	
	
	end))		

SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -2.0)*angles(math.rad(90),math.rad(0),math.rad(-20))},"Back","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -2.0)*angles(math.rad(90),math.rad(0),math.rad(20))},"Back","Out",.4)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
wait(.4)	
attack=false
end










		for i, v in pairs(Head:GetChildren()) do

if v:IsA("BasePart") and v.BrickColor.Name == "Institutional white" then
--v.Name = "Eye"
end


		end




function ClickCombo()
if Anim == "Fall" or Anim == "Jump" then
if Combo == 0 then		
--DownAT()	
end
else				
if Combo == 0 then
AT1()	
Combo = 1
elseif Combo == 1 then
AT2()	
Combo = 0	
elseif Combo == 2 then
AT3()
Combo = 0		
end
end
end

Button1DownF=function()

if attack==false then

ClickCombo()	
else

end	
	
end



KeyUpF=function(key)


	
end

Mouse.KeyDown:Connect(function(key)
key:lower()	
if key == "z" and attack ==false then
Attack1()
end
if key == "x" and attack ==false then
Attack2()
end
if key == "c" and attack ==false then
Attack3()
end
if key == "v" and attack ==false then
Attack4()
end
end)

	


if mememode == false then
	mememode=true
		lastid= "http://www.roblox.com/asset/?id=167664731" --1847367023
		
lastsongpos = 0
s2.TimePosition = lastsongpos
	SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(60))},"Quad","InOut",1)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-60))},"Quad","InOut",1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(-90))},"Quad","InOut",1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(90))},"Quad","InOut",1)
so("1837106999", Character,1, 1)
wait(1)

	
	lastid= "http://www.roblox.com/asset/?id=1837397373" --1847367023 194920243

lastsongpos = 0
s2.TimePosition = lastsongpos




		for i, v in pairs(Head:GetChildren()) do
if v:IsA("BasePart") and v.BrickColor.Name == "Really black" and v.Name ~= "Head" then

if v.Name == "Handle" then
	v.Transparency=1 	
v.Decal.Transparency=1 	
else
	SetTween(v,{Transparency=1},"Quad","InOut",.1)

end


end
if v:IsA("BasePart") and  (v.Name == "Eye1" or v.Name == "Eye2" )  then
SetTween(v,{Color=Color3.new(1,0,0)},"Quad","InOut",1)

SetTween(v.Mesh,{Scale=Vector3.new(0.8,5.8,.825)},"Quad","InOut",1)


SetTween(v.Mesh,{Offset=Vector3.new(0,-.5,0)},"Quad","InOut",1)



end


		end

coroutine.resume(coroutine.create(function()
 	  local MaskPart = Instance.new("Part")
		MaskPart.Reflectance = 0
		MaskPart.Transparency = 0
		MaskPart.CanCollide = false
		MaskPart.Locked = true
		MaskPart.Anchored=false
		MaskPart.BrickColor = BrickColor.new("Really blue")
		MaskPart.Name = "LMaskPart"
		MaskPart.Size = Vector3.new(.1,.1,.1)
		MaskPart.Material = "SmoothPlastic"
		MaskPart:BreakJoints()
		MaskPart.Parent = Head		
		MaskPart.CFrame = RootPart.CFrame	
		
	local SWeld=weld(MaskPart,Head,MaskPart,cf(-.75,-0,-1.25)*angles(math.rad(0),math.rad(0),math.rad(0)))
	SetTween(SWeld,{C0=CFrame.new(-2.75,0,-1.0)*angles(math.rad(0),math.rad(-15),math.rad(math.random(-15,15)))},"Elastic","Out",1.5)

local NewMaskMesh = Instance.new("SpecialMesh")
NewMaskMesh.Parent = MaskPart
NewMaskMesh.MeshId = "http://www.roblox.com/asset/?id=2349611011"
NewMaskMesh.TextureId = "http://www.roblox.com/asset/?id=2349706532"
NewMaskMesh.Scale = Vector3.new(3, 3.0999999, 3)/10
NewMaskMesh.MeshType = Enum.MeshType.FileMesh		
end))
coroutine.resume(coroutine.create(function()
 	  local MaskPart = Instance.new("Part")
		MaskPart.Reflectance = 0
		MaskPart.Transparency = 0
		MaskPart.CanCollide = false
		MaskPart.Locked = true
		MaskPart.Anchored=false
		MaskPart.BrickColor = BrickColor.new("Really blue")
		MaskPart.Name = "RMaskPart"
		MaskPart.Size = Vector3.new(.1,.1,.1)
		MaskPart.Material = "SmoothPlastic"
		MaskPart:BreakJoints()
		MaskPart.Parent = Head		
		MaskPart.CFrame = RootPart.CFrame	
		
	local SWeld=weld(MaskPart,Head,MaskPart,cf(.75,-0,-1.25)*angles(math.rad(0),math.rad(0),math.rad(0)))
	SetTween(SWeld,{C0=CFrame.new(2.75,0,-1.0)*angles(math.rad(0),math.rad(-15),math.rad(math.random(-15,15)))},"Elastic","Out",1)

local NewMaskMesh = Instance.new("SpecialMesh")
NewMaskMesh.Parent = MaskPart
NewMaskMesh.MeshId = "http://www.roblox.com/asset/?id=2349606351"
NewMaskMesh.TextureId = "http://www.roblox.com/asset/?id=2349706532"
NewMaskMesh.Scale = Vector3.new(3, 3.0999999, 3)/10
NewMaskMesh.MeshType = Enum.MeshType.FileMesh		
end))




coroutine.resume(coroutine.create(function()
wait(1)
local MoveVal = 1
while mememode == true do 

if MoveVal == 1 then
MoveVal =-1	
else	
MoveVal=1	
end

if Head:FindFirstChild("RMaskPart") then
	
	local HPa = Head:FindFirstChild("RMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(2.75+MoveVal/(math.random(30,40)/10),MoveVal/(math.random(60,80)/10),-1.0)*angles(math.rad(-30),math.rad(-15+MoveVal*5),math.rad(math.random(-15,15)))},"Quad","InOut",1)
end
if Head:FindFirstChild("LMaskPart") then
	local HPa = Head:FindFirstChild("LMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(-2.75-MoveVal/(math.random(30,40)/10),MoveVal/(math.random(60,80)/10),-1.0)*angles(math.rad(-30),math.rad(15+MoveVal*5),math.rad(math.random(-15,15)))},"Quad","InOut",1)
end
if Head:FindFirstChild("Eye1") then
		local HPa = Head:FindFirstChild("Eye1")
SetTween(HPa,{Color=Color3.new(.25+MoveVal/4,0,0)},"Quad","InOut",1)


end

if Head:FindFirstChild("Eye2") then
			local HPa = Head:FindFirstChild("Eye2")
SetTween(HPa,{Color=Color3.new(.25+MoveVal/4,0,0)},"Quad","InOut",1)	




end

wait(1)
end


if Head:FindFirstChild("RMaskPart") then
	
	local HPa = Head:FindFirstChild("RMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(.75,-0,-1.25)*angles(math.rad(-0),math.rad(-0),math.rad(0))},"Quad","InOut",.1)
end
if Head:FindFirstChild("LMaskPart") then
	local HPa = Head:FindFirstChild("LMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(-.75,-0.1,-1.25)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.1)
end





		for i, v in pairs(Head:GetChildren()) do
if v:IsA("BasePart") and v.BrickColor.Name == "Really black" and v.Name ~= "Head" then

if v.Name == "Handle" then
		coroutine.resume(coroutine.create(function()
		wait(.2)
	v.Transparency=0	
v.Decal.Transparency=0	
end))
else
	SetTween(v,{Transparency=0},"Quad","InOut",.1)

end


end
if v:IsA("BasePart") and  (v.Name == "Eye1" or v.Name == "Eye2" )  then
SetTween(v,{Color=Color3.new(1,1,1)},"Quad","InOut",1)
SetTween(v.Mesh,{Offset=Vector3.new(0,0,0)},"Quad","InOut",1)
SetTween(v.Mesh,{Scale=Vector3.new(1,1,1)},"Quad","InOut",1)




end
if v:IsA("BasePart") and  (v.Name == "RMaskPart" or v.Name == "LMaskPart" ) then
	coroutine.resume(coroutine.create(function()
		wait(.2)
v:Destroy()	
end))
end

		end



end))



lastsongpos = 0
s2.TimePosition = lastsongpos
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(90))},"Quad","InOut",.5)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(90))},"Quad","InOut",.5)

wait(.5)	
else
	mememode=false
	
	
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(90))},"Quad","InOut",.5)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(90))},"Quad","InOut",.5)

wait(.25)

	SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(60))},"Quad","InOut",.5)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-60))},"Quad","InOut",.5)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(90))},"Quad","InOut",.5)

wait(.5)

	
	CurId=CurId-1
	
	
end

attack = false










	



--math.rad(math.random(-math.random(1,5),math.random(1,5)))
gout= false
gnum = 0 
gnum2 = 20
crypos=0
	s3:play()
		s3.Volume = 0	
coroutine.resume(coroutine.create(function()
while Humanoid.Health>0.001 do 
	sine = sine + change
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)

  local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y


local wwalk = Anim

if RootPart.Velocity.y > 1 and hitfloor == nil then
Anim = "Jump"

elseif RootPart.Velocity.y < -1 and hitfloor == nil then
Anim = "Fall"
elseif Humanoid.Sit == true then
Anim = "Sit"	
elseif torvel < 1 and hitfloor ~= nil  then
Anim = "Idle"
elseif torvel > 2 and  hitfloor ~= nil  then

Anim = "Walk"
	
else
Anim = ""
	
end 

if Anim=="Jump" and wwalk == "Walk" and mememode==true then
			   local Portalfloor,PortalPos = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 80, Character)

			WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(0,60,0), Size2 = (VT(30,0,30)), Transparency = 0.2, Transparency2 = 1, CFrame = cn(PortalPos) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
					
end



coroutine.resume(coroutine.create(function()
	if mememode == true then
	if s3.Parent == nil or s3 == nil  then

s3 = s3c:Clone()
s3.Parent = Head
	s3.Name = "Crying"
--	s2.SoundId = lastid
	s3.Pitch = 0.5
	s3.Volume = 0
	s3.Looped = true
	s3.archivable = false
	s3.TimePosition = crypos

	s3:play()		

	
	else
crypos=s3.TimePosition		
	s3.Pitch = 0.5
	
	--s2.Volume = 1.5

s3.Looped = true
s3.SoundId = crying
s3.EmitterSize = 40
	end
	
	
	end
end))



coroutine.resume(coroutine.create(function()
	

	if s2.Parent == nil or s2 == nil  then

s2 = s2c:Clone()
s2.Parent = Torso
	s2.Name = "BGMusic"
--	s2.SoundId = lastid
	s2.Pitch = 1.5
	s2.Volume = 1.5
	s2.Looped = true
	s2.archivable = false
	s2.TimePosition = lastsongpos
	if playsong == true then
	s2:play()		
	elseif playsong == false then
	s2:stop()			
	end
	
	
	else
lastsongpos=s2.TimePosition		

if mememode == false then

	s2.Pitch = 0.85 --.85
	
	s2.Volume = 1.5

s2.Looped = true
s2.SoundId = lastid
s2.EmitterSize = 30
else


	s2.Pitch = 0.8 --.9
	
	s2.Volume = 2

s2.Looped = true
s2.SoundId = lastid
s2.EmitterSize = 35
end

	end
	
	
	
end))

if mememode == true then
gnum = gnum + 1
if gnum  >  gnum2 then
	
gnum2 = math.random(10,100)	
gnum = 0	
coroutine.resume(coroutine.create(function()
gout = true
s3.Volume = 3
wait(math.random(2,12)/50)


s3.Volume = 0
gout=false
end))


end 
end



inairvel=torvel


if inairvel > 30 then
inairvel=30	
end
inairvel=inairvel/50*2



if attack == false then
if Anim == "Jump" then
		change = 0.60*2
SetTween(RJW,{C0=RootCF* cn(0, 0 + (0.0395/2) * math.cos(sine / 8), -0.1 + 0.0395 * math.cos(sine / 8)) * angles(math.rad(-6.5 - 1.5 * math.cos(sine / 8))+inairvel/2, math.rad(0), math.rad(0))},"Quad","Out",0.25)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-26.5 + 2.5 * math.cos(sine / 8)), math.rad(0), math.rad(-0))},"Quad","Out",0.25)
SetTween(RW,{C0=CFrame.new(3.5 , -2.60, -.0) * angles(math.rad(-20 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 0 * math.cos(sine / 8)))},"Quad","InOut",0.1)
SetTween(LW,{C0=CFrame.new(-3.5, -2.6, -.0) * angles(math.rad(-20 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(-10 - 2 * math.cos(sine / 8)))},"Quad","InOut",0.1)
SetTween(RH,{C0=CFrame.new(0, -2+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.075)
SetTween(LH,{C0=CFrame.new(0, -2+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-25 +1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.075)


elseif Anim == "Fall" then 
		change = 0.60*2
SetTween(RJW,{C0=RootCF*cn(0, 0 + (0.0395/2) * math.cos(sine / 8), -0.1 + 0.0395 * math.cos(sine / 8)) * angles(math.rad(5.5 - 1.5 * math.cos(sine / 8))-inairvel, math.rad(0), math.rad(0))},"Quad","Out",0.25)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(26.5 + 2.5 * math.cos(sine / 8))+inairvel, math.rad(0), math.rad(-0))},"Quad","Out",0.25)
SetTween(RW,{C0=CFrame.new(3.2 , -1.50, .20) * angles(math.rad(140 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(45 + 0 * math.cos(sine / 8)))},"Quad","InOut",0.15)
SetTween(LW,{C0=CFrame.new(-3.2, -1.5, .20) * angles(math.rad(140 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(-45 - 2 * math.cos(sine / 8)))},"Quad","InOut",0.15)
SetTween(RH,{C0=CFrame.new(0, -1+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(0, -1+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-0 +1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
	
	
	
	
	
	
	

	
		
elseif Anim == "Idle" then
	
	
	
if mememode == false then
		
					change = 0.60
	Humanoid.JumpPower = 90	
	Humanoid.WalkSpeed=16					
local ADNum = .25
SetTween(RJW,{C0=RootCF*cn(0, 0, 2.1 + 0.2395 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * angles(math.rad(20 - 0 * math.cos(sine / 8)), math.rad((0 + .5* math.cos(sine / 4))), math.rad(-0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, -1, 2) *angles(math.rad(-3.5 - 1.5 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(10), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(3 , 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 12 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(-25), math.rad(30 - 6 * math.cos(sine / 8)))},"Quad","Out",0.2)
SetTween(LW,{C0=CFrame.new(-3, 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 12 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(25), math.rad(-30 + 6 * math.cos(sine / 8 )))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5- 6.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5+ 6.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
else
					change = 0.60
	Humanoid.JumpPower = 90	
	Humanoid.WalkSpeed=16					
local ADNum = .25
SetTween(RJW,{C0=RootCF*cn(0, 0, 2.1 + 0.2395 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * angles(math.rad(20 - 0 * math.cos(sine / 8)), math.rad((0 + .5* math.cos(sine / 4))), math.rad(-0))},"Quad","InOut",0.1)

if gout == false then
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, -1, 2) *angles(math.rad(13.5 - 1.5 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(0), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.1)
else 
SetTween(NeckW,{C0=NeckCF*CFrame.new(0+ (math.random(-10,10)/350), -1, 2 + (math.random(-10,10)/350)) *angles(math.rad(math.random(-math.random(1,5),math.random(1,5))), math.rad(0+math.random(-math.random(1,5),math.random(1,5))), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.0)
	
end
SetTween(RW,{C0=CFrame.new(3 , 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 6 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(-25), math.rad(30 - 2 * math.cos(sine / 8)))},"Quad","Out",0.2)
SetTween(LW,{C0=CFrame.new(-3, 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 6 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(25), math.rad(-30 + 2 * math.cos(sine / 8 )))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5- 2.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5+ 2.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
	
end		
		
	 
elseif Anim == "Walk" then
local speed=1
if mememode == true then
	speed=1.5
end



if mememode == false then
		

local ADNum = 1
		
			change = 2.6*speed
	Humanoid.JumpPower = 90*speed
	Humanoid.WalkSpeed=56*speed
SetTween(RJW,{C0=RootCF*CFrame.new(0, 1 + 1.0395 * math.cos(sine / 4), 2.4+ 0.855 * math.cos(sine / 4) + -math.sin(sine / 4) / 8) * angles(math.rad(20 - 6  * math.cos(sine / 4)), math.rad(12 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 70, math.rad(18 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, -1, 2 + 0.025 * math.cos(sine / 4)) * angles(math.rad(10 + 6.5 * math.cos(sine / 4)), math.rad(0 - 16 * math.cos(sine / 8)), math.rad(-18 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 16)},"Linear","InOut",WalkAnimMove/speed)
--SetTween(RW,{C0=CFrame.new(1.5, 0.6, 0) * angles(math.rad(21+8 * math.cos(sine / 8)), math.rad(-70) + RootPart.RotVelocity.Y / 80, math.rad(70) + RootPart.RotVelocity.Y / 120)},"Linear","InOut",WalkAnimMove/speed)
--SetTween(LW,{C0=CFrame.new(-1.5, 0.6, 0) * angles(math.rad(90-6* math.cos(sine / 4)), math.rad(0) + RootPart.RotVelocity.Y / 80, math.rad(-10) - RootPart.RotVelocity.Y / 90)},"Linear","InOut",WalkAnimMove/speed)
SetTween(RW,{C0=cf(3, 1.5 - 0.55 * math.cos(sine / 8) / 2,-1.1+ 0.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-10.5 + 90 * math.cos(sine / 8)) + -math.sin(sine / 8) / 2.5, math.rad(90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 + 22.5 * math.cos(sine / 8)), math.rad(-90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(LW,{C0=cf(-3, 1.5 + 0.55 * math.cos(sine / 8) / 2,-1.1+ -0.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-10.5 - 90 * math.cos(sine / 8)) + math.sin(sine / 8) / 2.5, math.rad(-90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 - 22.5 * math.cos(sine / 8)), math.rad(90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(RH,{C0=cf(0, -2.825 - 0.55 * math.cos(sine / 8) / 2,-1 + 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 - 50  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + -math.sin(sine / 8) / 2.5, math.rad(90 + 0 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(sine / 8)), math.rad(-90) - RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
SetTween(LH,{C0=cf(-0, -2.825 + 0.55 * math.cos(sine / 8) / 2,-1 - 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 + 50  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + math.sin(sine / 8) / 2.5, math.rad(-90 + 0 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(sine / 8)), math.rad(90)-  RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
else
	
	
	
	
local ADNum = 1
		
			change = 2.6*speed
	Humanoid.JumpPower = 90*speed
	Humanoid.WalkSpeed=76*speed
SetTween(RJW,{C0=RootCF*CFrame.new(0, 1 + 1.3395 * math.cos(sine / 4), 2.4+ 0.855 * math.cos(sine / 4) + -math.sin(sine / 4) / 8) * angles(math.rad(20 - 6  * math.cos(sine / 4)), math.rad(12 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 70, math.rad(18 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)


if gout == false then
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, 1, 0 + 0.025 * math.cos(sine / 4)) * angles(math.rad(10 + 6.5 * math.cos(sine / 4)), math.rad(0 - 3 * math.cos(sine / 8)), math.rad(-18 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 16)},"Linear","InOut",WalkAnimMove/speed)
else 
SetTween(NeckW,{C0=NeckCF*CFrame.new(0+ (math.random(-10,10)/350), 1, 0 + (math.random(-10,10)/350)) *angles(math.rad(math.random(-math.random(1,5),math.random(1,5))), math.rad(0+math.random(-math.random(1,5),math.random(1,5))), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.0)
	
end


--SetTween(RW,{C0=CFrame.new(1.5, 0.6, 0) * angles(math.rad(21+8 * math.cos(sine / 8)), math.rad(-70) + RootPart.RotVelocity.Y / 80, math.rad(70) + RootPart.RotVelocity.Y / 120)},"Linear","InOut",WalkAnimMove/speed)
--SetTween(LW,{C0=CFrame.new(-1.5, 0.6, 0) * angles(math.rad(90-6* math.cos(sine / 4)), math.rad(0) + RootPart.RotVelocity.Y / 80, math.rad(-10) - RootPart.RotVelocity.Y / 90)},"Linear","InOut",WalkAnimMove/speed)
SetTween(RW,{C0=cf(3, 1.5 - 0.55 * math.cos(sine / 8) / 2,-1.1- 2.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-1.5 + 30 * math.cos(sine / 8)) + -math.sin(sine / 8) / 2.5, math.rad(90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 + 22.5 * math.cos(sine / 8)), math.rad(-90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(LW,{C0=cf(-3, 1.5 + 0.55 * math.cos(sine / 8) / 2,-1.1- -2.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-1.5 - 30 * math.cos(sine / 8)) + math.sin(sine / 8) / 2.5, math.rad(-90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 - 22.5 * math.cos(sine / 8)), math.rad(90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(RH,{C0=cf(0, -2.825 - 0.55 * math.cos(sine / 8) / 2,-1 - 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 - 60  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + -math.sin(sine / 8) / 2.5, math.rad(90 - 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 + 6.5 * math.cos(sine / 8)), math.rad(-90) - RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
SetTween(LH,{C0=cf(-0, -2.825 + 0.55 * math.cos(sine / 8) / 2,-1 + 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 + 60  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + math.sin(sine / 8) / 2.5, math.rad(-90 - 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 - 6.5 * math.cos(sine / 8)), math.rad(90)-  RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
	
	
	
	
	
	
	
	
end		
	
	
	
	
	
	
	
	
	
	
elseif Anim == "Sit" then	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(1.5 , 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","Out",0.1)
SetTween(LW,{C0=CFrame.new(-1.5, 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(.5, -1, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-.5, -1, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
		
end
end

wait(Animstep)
end
end))
local Value1=MaybeOk(1,"29,30,31,10,12,29,30,31,0") warn(MaybeOk(1,"12,15,1,4,9,14,7,0"))





-----------------------------------------------------------------
--		  ____________ 
--		 /100101001011\    [-Deer Logger-]
--		[01-()-10-()-01]  when runing this script then i can
-- 		 \011001000101/     see who it isso its not the best
--		 [10\-'--'-/01]      plan you had and the white list 
--		  \10\    /10/		  is just there to get rid of sum 
--		   [10\__/10]			that copy the script
--          \======/
-----------------------------------------------------------------)    print("Clicked")
end)

Section:NewButton("Sakura Blade", "FE Sakura Blade", game.Players.LocalPlayer.Character["Surfboard"].Handle.Handle:Destroy()
game.Players.LocalPlayer.Character["Hat1"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Pal Hair"].Handle.Mesh:Destroy() --Pink Hair
game.Players.LocalPlayer.Character["Pink Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Kate Hair"].Handle.Mesh:Destroy() --LavanderHair
game.Players.LocalPlayer.Character["LavanderHair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Robloxclassicred"].Handle.Mesh:Destroy()
--game.Players.LocalPlayer.Character["HawkmanWings"].Handle.Mesh:Destroy()
 --VarietyShades02
 --TennisBall

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Arm", "Left Arm"}) do
    local arm = c[v]
    arm.Parent = nil
    arm.Transparency = 1
    arm.Parent = c
end

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Leg", "Left Leg"}) do
    local Leg = c[v]
    Leg.Parent = nil
    Leg.Transparency = 1
    Leg.Parent = c
end

local v3_net, v3_808 = Vector3.new(10000, 25.1, 10000), Vector3.new(-8000, 0, -8000)
		local function getNetlessVelocity(realPartVelocity)
			local mag = realPartVelocity.Magnitude
			if mag > 1 then
				local unit = realPartVelocity.Unit
				if (unit.Y > 10000) or (unit.Y < -10000) then
					return unit * (25.1 / unit.Y)
				end
			end 
			return v3_net + realPartVelocity * v3_808
		end
		local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
       head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -100
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.73,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.73,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.73,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.73,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 0
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

local hat2 = gp(cplayer, "Hat1", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0.5, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Pal Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(-0.5, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Pink Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Kate Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0) --LavanderHair

local hat2 = gp(cplayer, "LavanderHair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(0, 0, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Robloxclassicred", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, 0, 0) 
att2.Rotation = Vector3.new(90, 0, 0) 



backgroundcolortitle = Color3.fromHSV(0, 0, 0.3)
bordercolortitle = Color3.fromHSV(0, 0, 1)
local p = game.Players.LocalPlayer
local char = p.character
local larm = char:WaitForChild("Left Arm")
local rarm = char:WaitForChild("Right Arm")
local lleg = char:WaitForChild("Left Leg")
local rleg = char:WaitForChild("Right Leg")
local hed = char:WaitForChild("Head")
local torso = char:WaitForChild("Torso")
local root = char:WaitForChild("HumanoidRootPart")
local hum = char:FindFirstChildOfClass("Humanoid")
local debris = game:GetService("Debris")
local input = game:GetService("UserInputService")
local run = game:GetService("RunService")
local rs = run.RenderStepped
local wingpose = "Idle"
local DebrisModel = Instance.new("Model", char)
local lplr = game:GetService("Players").LocalPlayer
local remote = Instance.new("RemoteEvent")
local mouse = lplr:GetMouse()
local pose = "Idle"
local musicplay = true
local musictrack = 1
local blinktime = 0
local attacking = false
local blinking = false
local walking = false
DebrisModel.Name = "Debris"
repeat
	rs:wait()
until p.CharacterAppearanceLoaded
animsync = false
noidle = false
shift = false
control = false
stealth = false
function animation(token)
	if plr == lplr then
		pose = token
	end
	if -root.Velocity.Y / 1.5 > -5 and -root.Velocity.Y / 1.5 < 150 then
		velocityYFall = root.Velocity.Y / 1.5
	elseif -root.Velocity.Y / 1.5 < -5 then
		velocityYFall = 5
	elseif -root.Velocity.Y / 1.5 > 150 then
		velocityYFall = -150
	end
	if -root.Velocity.Y / 180 > 0 and -root.Velocity.Y / 180 < 1.2 then
		velocityYFall2 = root.Velocity.Y / 180
	elseif -root.Velocity.Y / 180 < 0 then
		velocityYFall2 = 0
	elseif -root.Velocity.Y / 180 > 1.2 then
		velocityYFall2 = -1.2
	end
	if -root.Velocity.Y / 1.5 > -5 and -root.Velocity.Y / 1.5 < 50 then
		velocityYFall3 = root.Velocity.Y / 1.5
	elseif -root.Velocity.Y / 1.5 < -5 then
		velocityYFall3 = 5
	elseif -root.Velocity.Y / 1.5 > 50 then
		velocityYFall3 = -50
	end
	if -root.Velocity.Y / 1.5 > -50 and -root.Velocity.Y / 1.5 < 20 then
		velocityYFall4 = root.Velocity.Y / 1.5
	elseif -5 > -root.Velocity.Y / 180 then
		velocityYFall4 = 5
	elseif -root.Velocity.Y / 180 > 50 then
		velocityYFall4 = -50
	end
	if root.RotVelocity.Y / 6 < 1 and root.RotVelocity.Y / 6 > -1 then
		neckrotY = root.RotVelocity.Y / 6
	elseif root.RotVelocity.Y / 6 < -1 then
		neckrotY = -1
	elseif root.RotVelocity.Y / 6 > 1 then
		neckrotY = 1
	end
	if root.RotVelocity.Y / 8 < 0.6 and root.RotVelocity.Y / 8 > -0.6 then
		neckrotY2 = root.RotVelocity.Y / 8
	elseif root.RotVelocity.Y / 8 < -0.6 then
		neckrotY2 = -0.6
	elseif root.RotVelocity.Y / 8 > 0.6 then
		neckrotY2 = 0.6
	end
	if root.RotVelocity.Y / 6 < 0.2 and root.RotVelocity.Y / 6 > -0.2 then
		torsorotY = root.RotVelocity.Y / 6
	elseif root.RotVelocity.Y / 6 < -0.2 then
		torsorotY = -0.2
	elseif root.RotVelocity.Y / 6 > 0.2 then
		torsorotY = 0.2
	end
	if root.RotVelocity.Y / 8 < 0.2 and root.RotVelocity.Y / 8 > -0.2 then
		torsorotY2 = root.RotVelocity.Y / 8
	elseif root.RotVelocity.Y / 8 < -0.2 then
		torsorotY2 = -0.2
	elseif root.RotVelocity.Y / 8 > 0.2 then
		torsorotY2 = 0.2
	end
	torsoY = -(torso.Velocity * Vector3.new(1, 0, 1)).magnitude / 20
	torsoY2 = -(torso.Velocity * Vector3.new(1, 0, 1)).magnitude / 36
	local rlegray = Ray.new(rleg.Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -1.75, 0))
	local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
	local llegray = Ray.new(lleg.Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -1.75, 0))
	local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
	local rightvector = (root.Velocity * root.CFrame.rightVector).X + (root.Velocity * root.CFrame.rightVector).Z
	local lookvector = (root.Velocity * root.CFrame.lookVector).X + (root.Velocity * root.CFrame.lookVector).Z
	if lookvector > hum.WalkSpeed then
		lookvector = hum.WalkSpeed
	end
	if lookvector < -hum.WalkSpeed then
		lookvector = -hum.WalkSpeed
	end
	if rightvector > hum.WalkSpeed then
		rightvector = hum.WalkSpeed
	end
	if rightvector < -hum.WalkSpeed then
		rightvector = -hum.WalkSpeed
	end
	local lookvel = lookvector / hum.WalkSpeed
	local rightvel = rightvector / hum.WalkSpeed
	if token == "Idle" then
		change = 1
		if noidle == false then
			hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.1), 0.4)
			hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0.05 * math.sin(sine / 16) + 0.15, math.rad(0) + 0.05 * math.cos(sine / 32), 0.01 * math.cos(sine / 32)), 0.1)
			if stealth == true then
				larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-0.85, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.4 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(10), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(40 - 1 * math.cos(sine / 8))), 0.2)
				rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.5 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(20), math.rad(25 - 1 * math.cos(sine / 16)), math.rad(-30 + 1 * math.cos(sine / 8))), 0.2)
			else
				larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 3, -0.05 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-2 + 4 * math.sin(sine / 16)), math.rad(0 - 5 * math.sin(sine / 16)), math.rad(-4 + 2 * math.cos(sine / 16))), 0.2)
				rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 3, -0.05 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-2 + 4 * math.sin(sine / 16)), math.rad(0 + 5 * math.sin(sine / 16)), math.rad(4 - 2 * math.cos(sine / 16))), 0.2)
			end
			torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.1 - 0.1 * math.cos(sine / 16) - hum.HipHeight, 0) * CFrame.Angles(math.rad(0 - 2 * math.cos(sine / 16)), math.rad(0), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		end
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(0, llegendPoint.Y - lleg.Position.Y, 0) * CFrame.new(-0.5, 0 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-1 + 2 * math.cos(sine / 16)), math.rad(10), math.rad(-5 + 1 * math.cos(sine / 32))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0, rlegendPoint.Y - rleg.Position.Y, 0) * CFrame.new(0.5, 0 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-1 + 2 * math.cos(sine / 16)), math.rad(-10), math.rad(5 + 1 * math.cos(sine / 32))), 0.1)
	elseif token == "Run" then
		if noidle == false then
			hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.1 - 0.1 * lookvel) * CFrame.Angles(0, torsorotY, math.rad(0) + torsorotY), 0.4)
			hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles((change / 10 * math.cos(sine / 2) + 0.1) * lookvel ^ 2, -(change / 10) * math.cos(sine / 4) - torsorotY / 5, change / 5 * math.cos(sine / 4)), 0.1)
			if stealth == true then
				rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.6 - movement / 40 * math.cos(sine / 4) / 2, movement / 100 * math.cos(sine / 4)) * CFrame.Angles(math.rad(-torso.Orientation.X - movement * 1 * math.cos(sine / 4) / 2) + -(movement / 20) * (math.sin(sine / 4) / 2), math.rad(0 - movement * 1 * math.cos(sine / 4)) / 2, math.rad(0)), 0.2)
			else
				rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5 + 0.12 * lookvel ^ 2 - movement / 40 * math.cos(sine / 4) / 3, movement / 150 + movement / 40 * math.cos(sine / 4)) * CFrame.Angles((math.rad(-5 - movement * 2 * math.cos(sine / 4)) + -(movement / 10) * math.sin(sine / 4)) * lookvel, math.rad(0 - movement * 2 * math.cos(sine / 4)), -math.rad(movement * 1 * 0.2 - movement * 1 * math.cos(sine / 2) * lookvel) + math.rad(-5 * rightvel)), 0.2)
			end
			larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5 + 0.12 * lookvel ^ 2 + movement / 40 * math.cos(sine / 4) / 3, movement / 150 - movement / 40 * math.cos(sine / 4)) * CFrame.Angles((math.rad(-5 + movement * 2 * math.cos(sine / 4)) + movement / 10 * math.sin(sine / 4)) * lookvel, math.rad(0 - movement * 2 * math.cos(sine / 4)), -math.rad(-(movement * 1) * 0.2 + movement * 1 * math.cos(sine / 2) * lookvel) + math.rad(-5 * rightvel)), 0.2)
			torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.05 + change / 2 * math.cos(sine / 2), 0) * CFrame.Angles(math.rad(-(change * 20) - movement / 20 * math.cos(sine / 2)) * lookvel, torsorotY2 + math.rad(0 - 4 * math.sin(sine / 4)), math.rad(-(change * 20) - movement / 20 * math.cos(sine / 2)) * rightvel + torsorotY2 + math.rad(0 - 1 * math.cos(sine / 4))), 0.1)
		end
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.85 - movement / 15 * math.cos(sine / 4) / 2, (-0.1 + movement / 15 * math.cos(sine / 4)) * (0.5 + 0.5 * lookvel)) * CFrame.Angles((math.rad(-10 * lookvel + change * 5 - movement * math.cos(sine / 4)) + -(movement / 10) * math.sin(sine / 4)) * lookvel, math.rad(0 + movement * 2 * math.cos(sine / 4)), (math.rad(change * 5 - movement * math.cos(sine / 4)) + -(movement / 10) * math.sin(sine / 4)) * (rightvector / (hum.WalkSpeed * 2))), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.85 + movement / 15 * math.cos(sine / 4) / 2, (-0.1 - movement / 15 * math.cos(sine / 4)) * (0.5 + 0.5 * lookvel)) * CFrame.Angles((math.rad(-10 * lookvel + change * 5 + movement * math.cos(sine / 4)) + movement / 10 * math.sin(sine / 4)) * lookvel, math.rad(0 + movement * 2 * math.cos(sine / 4)), (math.rad(change * 5 + movement * math.cos(sine / 4)) + movement / 10 * math.sin(sine / 4)) * (rightvector / (hum.WalkSpeed * 2))), 0.2)
	elseif token == "Jump" then
		change = 1
		if noidle == false then
			hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.1) * CFrame.Angles(0, 0, 0), 0.4)
			hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-velocityYFall3 / 5), 0, 0), 0.1)
			larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - velocityYFall3 / 70, 0) * CFrame.Angles(math.rad(-velocityYFall3 / 10), math.rad(0), math.rad(velocityYFall)), 0.2)
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - velocityYFall3 / 70, 0) * CFrame.Angles(math.rad(-velocityYFall3 / 10), math.rad(0), math.rad(-velocityYFall)), 0.2)
			torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-(change * 20) - movement / 20 * math.cos(sine / 2)) * (lookvector / (hum.WalkSpeed * 2)) + math.rad(velocityYFall3 / 10), math.rad(0), math.rad(-(change * 20) - movement / 20 * math.cos(sine / 2)) * (rightvector / (hum.WalkSpeed * 2))), 0.1)
		end
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.925, 0) * CFrame.Angles(math.rad(-35), math.rad(0), math.rad(-2)), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, 0, -0.8) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(2)), 0.2)
	elseif token == "Sit" then
		change = 1
		if noidle == false then
			hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.1), 0.4)
			hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0.05 * math.sin(sine / 16) + 0.15, 0.05 * math.cos(sine / 32), 0.01 * math.cos(sine / 32)), 0.1)
			larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 3, -0.05 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-2 + 4 * math.sin(sine / 16)), math.rad(-5 - 5 * math.sin(sine / 16)), math.rad(-6 + 2 * math.cos(sine / 16))), 0.2)
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 3, -0.05 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-2 + 4 * math.sin(sine / 16)), math.rad(5 + 5 * math.sin(sine / 16)), math.rad(6 - 2 * math.cos(sine / 16))), 0.2)
			torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.4 - 0.1 * math.cos(sine / 16) - hum.HipHeight, 0) * CFrame.Angles(math.rad(0 - 2 * math.cos(sine / 16)), math.rad(0), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		end
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.55 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(80 + 2 * math.cos(sine / 16)), math.rad(4), math.rad(-2 + 1 * math.cos(sine / 32))), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.55 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(80 + 2 * math.cos(sine / 16)), math.rad(-4), math.rad(2 + 1 * math.cos(sine / 32))), 0.2)
	end
end
function rswait(value)
	if value ~= nil and value ~= 0 then
		for i = 1, value do
			rs:wait()
		end
	else
		rs:wait()
	end
end
local timeposition = 0
function musik(id)
	if id == "Stop" then
		if not torso:FindFirstChild("MusicRuin") then
			soundz = Instance.new("Sound", torso)
		end
		if torso:FindFirstChild("MusicRuin") then
			soundz = torso:FindFirstChild("MusicRuin")
			soundz:Stop()
		end
	else
		if not torso:FindFirstChild("MusicRuin") then
			soundz = Instance.new("Sound", torso)
			for i = 1, 1 do
				local equalizer = Instance.new("EqualizerSoundEffect", soundz)
				equalizer.HighGain = 2
				equalizer.MidGain = 0
				equalizer.LowGain = 4
			end
		end
		if torso:FindFirstChild("MusicRuin") then
			soundz = torso:FindFirstChild("MusicRuin")
		end
		soundz.Volume = 10
		soundz.Name = "MusicRuin"
		soundz.Looped = true
		soundz.PlaybackSpeed = 1
		soundz.SoundId = "rbxassetid://" .. id
		soundz:Stop()
		soundz:Play()
	end
end
remote.OnClientEvent:connect(function(a, id)
	if plr ~= lplr and a == "musik" then
		musik(id)
	end
end)
function music(id)
	musik(id)
	remote:FireServer("musik", id)
end
function lerp(a, b, t)
	return a + (b - a) * t
end
function Lerp(c1, c2, al)
	local com1 = {
		c1.X,
		c1.Y,
		c1.Z,
		c1:toEulerAnglesXYZ()
	}
	local com2 = {
		c2.X,
		c2.Y,
		c2.Z,
		c2:toEulerAnglesXYZ()
	}
	for i, v in pairs(com1) do
		com1[i] = v + (com2[i] - v) * al
	end
	return CFrame.new(com1[1], com1[2], com1[3]) * CFrame.Angles(select(4, unpack(com1)))
end
function slerp(a, b, t)
	dot = a:Dot(b)
	if dot > 0.99999 or dot < -0.99999 then
		return t <= 0.5 and a or b
	else
		r = math.acos(dot)
		return (a * math.sin((1 - t) * r) + b * math.sin(t * r)) / math.sin(r)
	end
end
function clerp(c1, c2, al)
	local com1 = {
		c1.X,
		c1.Y,
		c1.Z,
		c1:toEulerAnglesXYZ()
	}
	local com2 = {
		c2.X,
		c2.Y,
		c2.Z,
		c2:toEulerAnglesXYZ()
	}
	for i, v in pairs(com1) do
		com1[i] = lerp(v, com2[i], al)
	end
	return CFrame.new(com1[1], com1[2], com1[3]) * CFrame.Angles(select(4, unpack(com1)))
end
function findAllNearestTorso(pos, dist)
	local list = workspace:GetDescendants()
	local torso = {}
	local temp, human, temp2
	for x = 1, #list do
		temp2 = list[x]
		if temp2.className == "Model" and temp2 ~= char then
			temp = temp2:findFirstChild("Head")
			human = temp2:findFirstChildOfClass("Humanoid")
			if temp ~= nil and human ~= nil and human.Health > 0 and dist > (temp.Position - pos).magnitude then
				table.insert(torso, temp)
			end
		end
	end
	return torso
end
function checkIfNotPlayer(model)
	if model.CanCollide == true and model ~= char and model.Parent ~= char and model.Parent.Parent ~= char and model.Parent.Parent ~= char and model.Parent ~= DebrisModel and model.Parent.Parent ~= DebrisModel and model.Parent.Parent.Parent ~= DebrisModel and model ~= wings and model.Parent ~= wings and model.Parent.Parent ~= wings then
		return true
	else
		return false
	end
end
function newWeld(wp0, wp1, wc0x, wc0y, wc0z)
	local wld = Instance.new("Weld", wp1)
	wld.Part0 = wp0
	wld.Part1 = wp1
	wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
	return wld
end
function weld(model)
	local parts, last = {}, nil
	local function scan(parent)
		for _, v in pairs(parent:GetChildren()) do
			if v:IsA("BasePart") then
				if last then
					local w = Instance.new("Weld")
					w.Name = ("%s_Weld"):format(v.Name)
					w.Part0, w.Part1 = last, v
					w.C0 = last.CFrame:inverse()
					w.C1 = v.CFrame:inverse()
					w.Parent = last
				end
				last = v
				table.insert(parts, v)
			end
			scan(v)
		end
	end
	scan(model)
	for _, v in pairs(parts) do
		v.Anchored = false
		v.Locked = true
		v.Anchored = false
		v.BackSurface = Enum.SurfaceType.SmoothNoOutlines
		v.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
		v.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
		v.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
		v.RightSurface = Enum.SurfaceType.SmoothNoOutlines
		v.TopSurface = Enum.SurfaceType.SmoothNoOutlines
		v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
		v.Massless = true
	end
end
function calculate(part, asd)
	local Head = hed
	local RightShoulder = asd
	local RightArm = part
	local MousePosition = mouse.Hit.p
	local ToMouse = (MousePosition - Head.Position).unit
	local Angle = math.acos(ToMouse:Dot(Vector3.new(0, 1, 0)))
	local FromRightArmPos = Head.Position + Head.CFrame:vectorToWorldSpace(Vector3.new(Head.Size.X / 2 + RightArm.Size.X / 2, Head.Size.Y / 2 - RightArm.Size.Z / 2, 0))
	local ToMouseRightArm = (MousePosition - FromRightArmPos) * Vector3.new(1, 0, 1).unit
	local Look = (Head.CFrame.lookVector * Vector3.new(1, 0, 1)).unit
	local LateralAngle = math.acos(ToMouseRightArm:Dot(Look))
	local Cross = Head.CFrame.lookVector:Cross(ToMouseRightArm)
	if LateralAngle > math.pi / 2 then
		LateralAngle = math.pi / 2
		local Torso = root
		local Point = Torso.CFrame:vectorToObjectSpace(mouse.Hit.p - Torso.CFrame.p)
		if 0 < Point.Z then
			if 0 < Point.X and RightArm == rarm then
				Torso.CFrame = CFrame.new(Torso.Position, Vector3.new(mouse.Hit.X, Torso.Position.Y, mouse.Hit.Z)) * CFrame.Angles(0, math.rad(110), 0)
			elseif 0 > Point.X and RightArm == rarm then
				Torso.CFrame = CFrame.new(Torso.Position, Vector3.new(mouse.Hit.X, Torso.Position.Y, mouse.Hit.Z)) * CFrame.Angles(0, math.rad(-110), 0)
			end
		end
	end
	if 0 > Cross.Y then
		LateralAngle = -LateralAngle
	end
	return (CFrame.Angles(math.pi / 2 - Angle, math.pi / 2 + LateralAngle, math.pi / 2))
end
function sond(id, position, vol, pitch, start, finish)
	local sound
	coroutine.resume(coroutine.create(function()
		local part = Instance.new("Part", workspace)
		part.Position = position
		part.Size = Vector3.new(0, 0, 0)
		part.CanCollide = false
		part.Transparency = 1
		part.Anchored = true
		sound = Instance.new("Sound", part)
		sound.SoundId = "rbxassetid://" .. id
		repeat
			rs:wait()
		until sound.IsLoaded
		if vol ~= nil then
			sound.Volume = vol
		end
		if pitch ~= nil then
			sound.PlaybackSpeed = pitch
		end
		if start ~= nil then
			sound.TimePosition = start
		end
		if finish ~= nil then
			debris:AddItem(part, finish - start)
		else
			debris:AddItem(part, sound.TimeLength)
		end
		sound:Play()
	end))
	return sound
end
remote.OnClientEvent:connect(function(a, id, position, vol, pitch, start, finish)
	if plr ~= lplr and a == "sond" then
		sond(id, position, vol, pitch, start, finish)
	end
end)
function sound(id, position, vol, pitch, start, finish)
	if plr == lplr then
		local part = sond(id, position, vol, pitch, start, finish)
		remote:FireServer("sond", id, position, vol, pitch, start, finish)
		return part
	end
end
function computeDirection(vec)
	local lenSquared = vec.magnitude * vec.magnitude
	local invSqrt = 1 / math.sqrt(lenSquared)
	return Vector3.new(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
end
local shaking = 0
function shake(num)
	if num > shaking then
		shaking = num
	end
end
game:GetService("RunService").RenderStepped:connect(function()
	--hum.CameraOffset = Vector3.new(math.random(-1, 1), math.random(-1, 1), math.random(-1, 1)) * (shaking / 100)
	if shaking > 0 then
		shaking = shaking - 1
	else
		shaking = 0
	end
end)
plr = p
DebrisModel = Instance.new("Model", plr.Character)
DebrisModel.Name = "DebrisModel"
function Effekt(mesh, size, transparency, material, color, position, rotation, positionchange, sizechange, rotationchange, transparencychange, acceleration)
	local part = Instance.new("Part", DebrisModel)
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(1, 1, 1)
	part.Transparency = transparency
	part.Material = material
	part.Color = color
	part.CFrame = CFrame.new(position) * CFrame.Angles(math.rad(rotation.X), math.rad(rotation.Y), math.rad(rotation.Z))
	local partmesh = Instance.new("SpecialMesh", part)
	if tonumber(mesh) == nil then
		partmesh.MeshType = mesh
	else
		partmesh.MeshId = "rbxassetid://" .. mesh
	end
	partmesh.Scale = size
	local pvalue = Instance.new("Vector3Value", part)
	pvalue.Name = "Position"
	pvalue.Value = positionchange
	local svalue = Instance.new("Vector3Value", part)
	svalue.Name = "Size"
	svalue.Value = sizechange
	local rvalue = Instance.new("Vector3Value", part)
	rvalue.Name = "Rotation"
	rvalue.Value = rotationchange
	local tvalue = Instance.new("NumberValue", part)
	tvalue.Name = "Transparency"
	tvalue.Value = transparencychange
	local avalue = Instance.new("NumberValue", part)
	avalue.Name = "Acceleration"
	avalue.Value = acceleration
	part.Name = "EFFECT"
	return part
end
remote.OnClientEvent:connect(function(a, mesh, size, transparency, material, color, position, rotation, positionchange, sizechange, rotationchange, transparencychange, acceleration)
	if plr ~= lplr and a == "effekt" then
		Effekt(mesh, size, transparency, material, color, position, rotation, positionchange, sizechange, rotationchange, transparencychange, acceleration)
	end
end)
function Effect(mesh, size, transparency, material, color, position, rotation, positionchange, sizechange, rotationchange, transparencychange, acceleration)
	local part = Effekt(mesh, size, transparency, material, color, position, rotation, positionchange, sizechange, rotationchange, transparencychange, acceleration)
	remote:FireServer("effekt", mesh, size, transparency, material, color, position, rotation, positionchange, sizechange, rotationchange, transparencychange, acceleration)
	return part
end
rs:connect(function()
	coroutine.resume(coroutine.create(function()
		for i, v in pairs(DebrisModel:GetChildren()) do
			if v:isA("BasePart") then
				v.LocalTransparencyModifier = 0
			end
		end
		if not plr.Character:FindFirstChild("DebrisModel") then
			DebrisModel = Instance.new("Model", plr.Character)
			DebrisModel.Name = "DebrisModel"
		end
		for i, v in pairs(DebrisModel:GetChildren()) do
			if v:IsA("BasePart") and v.Name == "EFFECT" then
				local pvalue = v:FindFirstChild("Position").Value
				local svalue = v:FindFirstChild("Size").Value
				local rvalue = v:FindFirstChild("Rotation").Value
				local tvalue = v:FindFirstChild("Transparency").Value
				local avalue = v:FindFirstChild("Acceleration").Value
				local mesh = v:FindFirstChild("Mesh")
				mesh.Scale = mesh.Scale + svalue
				v:FindFirstChild("Size").Value = v:FindFirstChild("Size").Value + Vector3.new(1, 1, 1) * avalue
				v.Transparency = v.Transparency + tvalue
				v.CFrame = CFrame.new(pvalue) * v.CFrame * CFrame.Angles(math.rad(rvalue.X), math.rad(rvalue.Y), math.rad(rvalue.Z))
				if v.Transparency >= 1 or 0 > mesh.Scale.X or 0 > mesh.Scale.Y or 0 > mesh.Scale.Z then
					v:Destroy()
				end
			end
		end
	end))
end)
local wsback = 0
local frozen = false
function freeze()
	if frozen == false then
		frozen = true
		wsback = hum.WalkSpeed
		hum.WalkSpeed = 1
	else
		frozen = false
		hum.WalkSpeed = wsback
	end
end
function litnin(Part0, Part1, Times, Offset, Color, Thickness, Trans)
	local magz = (Part0 - Part1).magnitude
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1, Times do
		local li = Instance.new("Part", DebrisModel)
		li.TopSurface = 0
		li.Material = Enum.Material.Neon
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = Trans or 0.4
		li.Color = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(Thickness, Thickness, magz / Times)
		local lim = Instance.new("BlockMesh", li)
		local Offzet = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
		local trolpos = CFrame.new(curpos, Part1) * CFrame.new(0, 0, magz / Times).p + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).magnitude
			li.Size = Vector3.new(Thickness, Thickness, magz2)
			li.CFrame = CFrame.new(curpos, Part1) * CFrame.new(0, 0, -magz2 / 2)
		else
			li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / Times / 2)
		end
		curpos = li.CFrame * CFrame.new(0, 0, magz / Times / 2).p
		li.Name = "LIGHTNING"
	end
end
remote.OnClientEvent:connect(function(a, Part0, Part1, Times, Offset, Color, Thickness, Trans)
	if plr ~= lplr and a == "litnin" then
		litnin(Part0, Part1, Times, Offset, Color, Thickness, Trans)
	end
end)
function Lightning(Part0, Part1, Times, Offset, Color, Thickness, Trans)
	local part = litnin(Part0, Part1, Times, Offset, Color, Thickness, Trans)
	remote:FireServer("litnin", Part0, Part1, Times, Offset, Color, Thickness, Trans)
end
function createimpakt(a, b, c, d, endPoint, ori)
	coroutine.resume(coroutine.create(function()
		local temppart = Instance.new("Part", DebrisModel)
		for i = 1, 8 do
			local bullet = Instance.new("Part", workspace)
			bullet.Material = a
			bullet.Color = b
			bullet.TopSurface = c
			bullet.BottomSurface = d
			bullet.Size = Vector3.new(10, 10, 10)
			bullet.CFrame = root.CFrame
			bullet.CanCollide = false
			bullet.Velocity = Vector3.new(math.random(-80, 80), 120, math.random(-80, 80))
			bullet.RotVelocity = Vector3.new(math.random(-80, 80), math.random(-80, 80), math.random(-80, 80)) / 10
			bullet:BreakJoints()
			debris:AddItem(bullet, 5)
		end
		for z = 1, 2 do
			for i = 1, 40 do
				temppart.CFrame = CFrame.new(endPoint, endPoint + Vector3.new(1, 0, 0)) * CFrame.Angles(math.rad(ori.X), math.rad(ori.Y), math.rad(ori.Z)) * CFrame.Angles(0, math.rad(i / 40 * 360), 0) * CFrame.new(0, math.random(-10, -5) + z * 5, math.random(-5, 5) - (10 + z * 10))
				local bullet = Instance.new("Part", workspace)
				bullet.Material = a
				bullet.Anchored = true
				bullet.CanCollide = false
				bullet.Color = b
				bullet.TopSurface = c
				bullet.BottomSurface = d
				bullet.Size = Vector3.new(10, 15, 20)
				bullet.CFrame = CFrame.new(temppart.Position + Vector3.new(0, -10, 0), endPoint + Vector3.new(0, -1, 0))
				debris:AddItem(bullet, 5)
			end
		end
		temppart:Destroy()
	end))
end
remote.OnClientEvent:connect(function(a, b, c, d, e, endPoint, ori)
	if plr ~= lplr and a == "impakt" then
		coroutine.resume(coroutine.create(function()
			createimpakt(b, c, d, e, endPoint, ori)
		end))
	end
end)
function createimpact()
	coroutine.resume(coroutine.create(function()
		local ray = Ray.new(root.Position, Vector3.new(0, -1000, 0))
		local part, endPoint = workspace:FindPartOnRay(ray, char)
		createimpakt(part.Material, part.Color, part.TopSurface, part.BottomSurface, endPoint, part.Orientation)
		remote:FireServer("impakt", part.Material, part.Color, part.TopSurface, part.BottomSurface, endPoint, part.Orientation)
	end))
end
function partchange(target, material, color)
	for i, v in pairs(target:children()) do
		if v:IsA("BasePart") then
			v.Color = color
			v.Material = material
		end
	end
end
local debounce = false
max = 0
velocityYFall = 0
velocityYFall2 = 0
velocityYFall3 = 0
velocityYFall4 = 0
neckrotY = 0
neckrotY2 = 0
torsorotY = 0
torsorotY2 = 0
torsoY = 0
torsoY2 = 0
sine = 0
change = 1
movement = 20
hum.WalkSpeed = 50
timeranim = 0
running = false
jumped = false
icolor = 1
imode = false
didjump = false
jumppower = 0
debounceimpact = false
noidlew = false
drew = false
sidestep = 0
local size = 1
local ranonce = true
if not larm:FindFirstChild("Weld") then
	newWeld(torso, larm, -1.5, 0.5, 0)
	ranonce = false
end
if not rarm:FindFirstChild("Weld") then
	newWeld(torso, rarm, 1.5, 0.5, 0)
	ranonce = false
end
if not lleg:FindFirstChild("Weld") then
	newWeld(torso, lleg, -0.5, -1, 0)
	ranonce = false
end
if not rleg:FindFirstChild("Weld") then
	newWeld(torso, rleg, 0.5, -1, 0)
	ranonce = false
end
if not torso:FindFirstChild("Weld") then
	newWeld(root, torso, 0, -1, 0)
	ranonce = false
end
if not hed:FindFirstChild("Weld") then
	newWeld(torso, hed, 0, 1.5, 0)
	ranonce = false
end
larm.Weld.C1 = CFrame.new(0, 0.5, 0)
rarm.Weld.C1 = CFrame.new(0, 0.5, 0)
lleg.Weld.C1 = CFrame.new(0, 1, 0)
rleg.Weld.C1 = CFrame.new(0, 1, 0)
torso.Weld.C1 = CFrame.new(0, -1, 0)
if ranonce then
	for i, v in pairs(char:GetChildren()) do
		if v ~= DebrisModel and v:IsA("Model") then
			v:Destroy()
		end
	end
end
skin_custom = false
skin_color = BrickColor.new("Light orange")
custom_outfits = false
function addblood(target)
	for i = 1, 5 do
		Effect(Enum.MeshType.Sphere, Vector3.new(2, 2, 2) * 1, 0.5, Enum.Material.Glass, Color3.new(1, 0, 0), (target:FindFirstChild("Torso") or target:FindFirstChild("UpperTorso")).Position, Vector3.new(math.random(0, 360), math.random(0, 360), math.random(0, 360)), Vector3.new(), Vector3.new(-1, 2, -1) * 0.2, Vector3.new(), 0, 0)
	end
	if target:FindFirstChild("Torso") then
		sound(206082273, target.Torso.Position, 10)
	elseif target:FindFirstChild("UpperTorso") then
		sound(206082273, target.UpperTorso.Position, 10)
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 30 do
			rs:wait()
			for i, v in pairs(target:GetChildren()) do
				if v:IsA("BasePart") and v ~= target:FindFirstChild("HumanoidRootPart") then
					local ef = Effect(Enum.MeshType.Sphere, Vector3.new(1, 1, 1) * 1, 0.5, Enum.Material.Glass, Color3.new(1, 0, 0), v.Position + Vector3.new(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)) / 720, Vector3.new(math.random(0, 360), math.random(0, 360), math.random(0, 360)), Vector3.new(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)) / 3600, Vector3.new(-1, -1, -1) * 0.2, Vector3.new(), 0, 0)
					ef.Anchored = false
				end
			end
		end
	end))
end
remote.OnClientEvent:connect(function(a, b)
	if a == "dead" and b ~= hum then
		addblood(b.Parent)
	end
end)
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
SpecialMesh2 = Instance.new("SpecialMesh")
Part3 = Instance.new("Part")
SpecialMesh4 = Instance.new("SpecialMesh")
Part5 = Instance.new("Part")
SpecialMesh6 = Instance.new("SpecialMesh")
Part7 = Instance.new("Part")
Part8 = Instance.new("Part")
SpecialMesh9 = Instance.new("SpecialMesh")
Part10 = Instance.new("Part")
SpecialMesh11 = Instance.new("SpecialMesh")
Part12 = Instance.new("Part")
SpecialMesh13 = Instance.new("SpecialMesh")
Part14 = Instance.new("Part")
SpecialMesh15 = Instance.new("SpecialMesh")
Part16 = Instance.new("Part")
SpecialMesh17 = Instance.new("SpecialMesh")
Part18 = Instance.new("Part")
Part19 = Instance.new("Part")
SpecialMesh20 = Instance.new("SpecialMesh")
Part21 = Instance.new("Part")
Part22 = Instance.new("Part")
SpecialMesh23 = Instance.new("SpecialMesh")
Part24 = Instance.new("Part")
SpecialMesh25 = Instance.new("SpecialMesh")
Part26 = Instance.new("Part")
Model0.Name = "Deus"
Model0.Parent = char
Part1.Parent = Model0
Part1.BrickColor = BrickColor.new("Black")
Part1.Rotation = Vector3.new(0, 0, 90)
Part1.Anchored = true
Part1.CanCollide = false
Part1.Size = Vector3.new(1.39999998, 0.200000003, 0.200000003)
Part1.Name = "Handle"
Part1.CFrame = CFrame.new(95.6999893, 37.4249992, 39, -4.37113883E-8, -1, 0, 1, -4.37113883E-8, 0, 0, 0, 0.99999994)
Part1.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part1.Position = Vector3.new(95.6999893, 37.4249992, 39)
Part1.Orientation = Vector3.new(0, 0, 90)
Part1.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh2.Parent = Part1
SpecialMesh2.MeshType = Enum.MeshType.Cylinder
Part3.Parent = Model0
Part3.Material = Enum.Material.Neon
Part3.BrickColor = BrickColor.new("Really red")
Part3.Rotation = Vector3.new(0, -90, 0)
Part3.Anchored = true
Part3.CanCollide = false
Part3.Size = Vector3.new(0.219999984, 0.0999999866, 0.110000007)
Part3.CFrame = CFrame.new(95.6999893, 36.6650009, 39, 1.19248806E-8, 0, -1, 0, 1, 0, 1, 0, 1.19248806E-8)
Part3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.Color = Color3.new(1, 0, 0)
Part3.Position = Vector3.new(95.6999893, 36.6650009, 39)
Part3.Orientation = Vector3.new(0, -90, 0)
Part3.Color = Color3.new(1, 0, 0)
SpecialMesh4.Parent = Part3
SpecialMesh4.MeshType = Enum.MeshType.Cylinder
Part5.Parent = Model0
Part5.BrickColor = BrickColor.new("Black")
Part5.Rotation = Vector3.new(-90, 0, 90)
Part5.Anchored = true
Part5.CanCollide = false
Part5.Size = Vector3.new(0.300000012, 0.200000003, 0.170000002)
Part5.CFrame = CFrame.new(95.2999878, 38.2099991, 39, -1.31134158E-7, -1, -8.74227908E-8, -2.50343476E-7, -8.74227553E-8, 0.99999994, -1, 1.31134186E-7, -2.50343419E-7)
Part5.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part5.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part5.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part5.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part5.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part5.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part5.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part5.Position = Vector3.new(95.2999878, 38.2099991, 39)
Part5.Orientation = Vector3.new(-89.9799957, -160.75, -109.25)
Part5.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh6.Parent = Part5
SpecialMesh6.MeshType = Enum.MeshType.Wedge
Part7.Parent = Model0
Part7.BrickColor = BrickColor.new("Black")
Part7.Rotation = Vector3.new(0, 0, 90)
Part7.Anchored = true
Part7.CanCollide = false
Part7.Size = Vector3.new(0.120000079, 0.270000011, 0.200000003)
Part7.CFrame = CFrame.new(95.6949921, 36.6650009, 39, -4.37113883E-8, -1, 0, 1, -4.37113883E-8, 0, 0, 0, 0.99999994)
Part7.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part7.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part7.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part7.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part7.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part7.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part7.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part7.Position = Vector3.new(95.6949921, 36.6650009, 39)
Part7.Orientation = Vector3.new(0, 0, 90)
Part7.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part8.Parent = Model0
Part8.BrickColor = BrickColor.new("Black")
Part8.Rotation = Vector3.new(90, 0, -90)
Part8.Anchored = true
Part8.CanCollide = false
Part8.Size = Vector3.new(0.120000005, 0.349999994, 0.590000033)
Part8.CFrame = CFrame.new(95.6749878, 43.3899994, 39, 4.37113883E-8, 1, 8.74227695E-8, 1.62920685E-7, 8.74227624E-8, -0.99999994, -1, 4.37114025E-8, -1.62920657E-7)
Part8.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part8.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part8.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part8.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part8.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part8.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part8.Position = Vector3.new(95.6749878, 43.3899994, 39)
Part8.Orientation = Vector3.new(89.9799957, 151.779999, 61.7799988)
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh9.Parent = Part8
SpecialMesh9.MeshType = Enum.MeshType.Wedge
Part10.Parent = Model0
Part10.BrickColor = BrickColor.new("Black")
Part10.Rotation = Vector3.new(-90, 0, -90)
Part10.Anchored = true
Part10.CanCollide = false
Part10.Size = Vector3.new(0.200000003, 0.110000014, 0.120000005)
Part10.CFrame = CFrame.new(95.8849869, 36.6650009, 39, 4.37113883E-8, 1, 8.74227695E-8, -7.54979013E-8, -8.74227695E-8, 0.99999994, 1, -4.37113954E-8, 7.54978871E-8)
Part10.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part10.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part10.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part10.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part10.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part10.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part10.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part10.Position = Vector3.new(95.8849869, 36.6650009, 39)
Part10.Orientation = Vector3.new(-89.9799957, 49.1899986, -139.190002)
Part10.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh11.Parent = Part10
SpecialMesh11.MeshType = Enum.MeshType.Wedge
Part12.Parent = Model0
Part12.BrickColor = BrickColor.new("Black")
Part12.Rotation = Vector3.new(90, 0, -90)
Part12.Anchored = true
Part12.CanCollide = false
Part12.Size = Vector3.new(0.300000012, 0.200000003, 0.170000002)
Part12.CFrame = CFrame.new(95.2999878, 38.3800011, 39, 4.37113883E-8, 1, 8.74227695E-8, 1.62920685E-7, 8.74227624E-8, -0.99999994, -1, 4.37114025E-8, -1.62920657E-7)
Part12.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part12.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part12.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part12.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part12.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part12.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part12.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part12.Position = Vector3.new(95.2999878, 38.3800011, 39)
Part12.Orientation = Vector3.new(89.9799957, 151.779999, 61.7799988)
Part12.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh13.Parent = Part12
SpecialMesh13.MeshType = Enum.MeshType.Wedge
Part14.Parent = Model0
Part14.Material = Enum.Material.Neon
Part14.BrickColor = BrickColor.new("Really red")
Part14.Rotation = Vector3.new(0, -90, 0)
Part14.Anchored = true
Part14.CanCollide = false
Part14.Size = Vector3.new(0.319999993, 0.149999991, 0.150000021)
Part14.CFrame = CFrame.new(95.6999893, 38.2099991, 39, 1.19248806E-8, 0, -1, 0, 1, 0, 1, 0, 1.19248806E-8)
Part14.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part14.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part14.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part14.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part14.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part14.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part14.Color = Color3.new(1, 0, 0)
Part14.Position = Vector3.new(95.6999893, 38.2099991, 39)
Part14.Orientation = Vector3.new(0, -90, 0)
Part14.Color = Color3.new(1, 0, 0)
SpecialMesh15.Parent = Part14
SpecialMesh15.MeshType = Enum.MeshType.Cylinder
Part16.Parent = Model0
Part16.BrickColor = BrickColor.new("Black")
Part16.Rotation = Vector3.new(-90, 0, -90)
Part16.Anchored = true
Part16.CanCollide = false
Part16.Size = Vector3.new(0.300000012, 0.200000003, 0.170000002)
Part16.CFrame = CFrame.new(96.0999908, 38.2099991, 39, 4.37113883E-8, 1, 8.74227695E-8, -7.54979013E-8, -8.74227695E-8, 0.99999994, 1, -4.37113954E-8, 7.54978871E-8)
Part16.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part16.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part16.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part16.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part16.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part16.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part16.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part16.Position = Vector3.new(96.0999908, 38.2099991, 39)
Part16.Orientation = Vector3.new(-89.9799957, 49.1899986, -139.190002)
Part16.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh17.Parent = Part16
SpecialMesh17.MeshType = Enum.MeshType.Wedge
Part18.Parent = Model0
Part18.BrickColor = BrickColor.new("Black")
Part18.Rotation = Vector3.new(0, 0, 90)
Part18.Anchored = true
Part18.CanCollide = false
Part18.Size = Vector3.new(4.80000019, 0.349999994, 0.120000005)
Part18.Name = "HitBox"
Part18.CFrame = CFrame.new(95.6749878, 40.6949997, 39, -4.37113883E-8, -1, 0, 1, -4.37113883E-8, 0, 0, 0, 0.99999994)
Part18.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part18.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part18.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part18.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part18.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part18.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part18.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part18.Position = Vector3.new(95.6749878, 40.6949997, 39)
Part18.Orientation = Vector3.new(0, 0, 90)
Part18.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part19.Parent = Model0
Part19.BrickColor = BrickColor.new("Black")
Part19.Rotation = Vector3.new(0, -90, 0)
Part19.Anchored = true
Part19.CanCollide = false
Part19.Size = Vector3.new(0.339999974, 0.12999998, 0.13000001)
Part19.CFrame = CFrame.new(95.6999893, 38.2099991, 39, 1.19248806E-8, 0, -1, 0, 1, 0, 1, 0, 1.19248806E-8)
Part19.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part19.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part19.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part19.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part19.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part19.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part19.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part19.Position = Vector3.new(95.6999893, 38.2099991, 39)
Part19.Orientation = Vector3.new(0, -90, 0)
Part19.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh20.Parent = Part19
SpecialMesh20.MeshType = Enum.MeshType.Cylinder
Part21.Parent = Model0
Part21.BrickColor = BrickColor.new("Black")
Part21.Rotation = Vector3.new(0, 0, 90)
Part21.Anchored = true
Part21.CanCollide = false
Part21.Size = Vector3.new(0.170000076, 0.600000024, 0.300000012)
Part21.CFrame = CFrame.new(95.6999893, 38.2099991, 39, -4.37113883E-8, -1, 0, 1, -4.37113883E-8, 0, 0, 0, 0.99999994)
Part21.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part21.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part21.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part21.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part21.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part21.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part21.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part21.Position = Vector3.new(95.6999893, 38.2099991, 39)
Part21.Orientation = Vector3.new(0, 0, 90)
Part21.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part22.Parent = Model0
Part22.BrickColor = BrickColor.new("Black")
Part22.Rotation = Vector3.new(0, -90, 0)
Part22.Anchored = true
Part22.CanCollide = false
Part22.Size = Vector3.new(0.239999965, 0.0799999759, 0.0900000036)
Part22.CFrame = CFrame.new(95.6999893, 36.6650009, 39, 1.19248806E-8, 0, -1, 0, 1, 0, 1, 0, 1.19248806E-8)
Part22.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part22.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part22.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part22.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part22.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part22.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part22.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part22.Position = Vector3.new(95.6999893, 36.6650009, 39)
Part22.Orientation = Vector3.new(0, -90, 0)
Part22.Color = Color3.new(0.105882, 0.164706, 0.207843)
SpecialMesh23.Parent = Part22
SpecialMesh23.MeshType = Enum.MeshType.Cylinder

Part18.Transparency = 1
Part5.Transparency = 1
Part8.Transparency = 1
Part19.Transparency = 1
Part1.Transparency = 1
Part19.Transparency = 1
Part7.Transparency = 1
Part12.Transparency = 1
Part24.Transparency = 1
Part3.Transparency = 1
Part16.Transparency = 1
Part21.Transparency = 1
Part26.Transparency = 1

Part24.Parent = Model0
Part24.Material = Enum.Material.Neon
Part24.BrickColor = BrickColor.new("Really red")
Part24.Rotation = Vector3.new(90, 0, -90)
Part24.Anchored = true
Part24.CanCollide = false
Part24.Size = Vector3.new(0.100000001, 0.399000019, 0.699999988)
Part24.CFrame = CFrame.new(95.7004852, 43.4449997, 39, 4.37113883E-8, 1, 8.74227695E-8, 1.62920685E-7, 8.74227624E-8, -0.99999994, -1, 4.37114025E-8, -1.62920657E-7)
Part24.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part24.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part24.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part24.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part24.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part24.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part24.Color = Color3.new(1, 0, 0)
Part24.Position = Vector3.new(95.7004852, 43.4449997, 39)
Part24.Orientation = Vector3.new(89.9799957, 151.779999, 61.7799988)
Part24.Color = Color3.new(1, 0, 0)
Part24.Transparency = 1
SpecialMesh25.Parent = Part24
SpecialMesh25.MeshType = Enum.MeshType.Wedge
Part26.Parent = Model0
Part26.Material = Enum.Material.Neon
Part26.BrickColor = BrickColor.new("Really red")
Part26.Rotation = Vector3.new(0, 0, 90)
Part26.Anchored = true
Part26.CanCollide = false
Part26.Size = Vector3.new(4.80000019, 0.399000019, 0.100000001)
Part26.CFrame = CFrame.new(95.7004929, 40.6949997, 39, -4.37113883E-8, -1, 0, 1, -4.37113883E-8, 0, 0, 0, 0.99999994)
Part26.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part26.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part26.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part26.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part26.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part26.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part26.Color = Color3.new(1, 0, 0)
Part26.Position = Vector3.new(95.7004929, 40.6949997, 39)
Part26.Orientation = Vector3.new(0, 0, 90)
Part26.Color = Color3.new(1, 0, 0)
Part26.Transparency = 1
Part18.Transparency = 1
Part19.Transparency = 1
Part22.Transparency = 1
Part24.Transparency = 1
Part14.Transparency = 1
Part10.Transparency = 1

game:GetService("Players").LocalPlayer.Character["Surfboard"].Handle.att1_Handle.Parent = Part26
Part26.att1_Handle.Rotation = Vector3.new(90,90,0)
Part26.att1_Handle.Position = Vector3.new(2.35,0,0) 

Sword = Model0
weld(Sword)
newWeld(torso, Sword.Handle, -1, -1, 0.5) 

game:GetService("Players").LocalPlayer.Character["PogoStick"].Handle.att1_Handle.Parent = Sword.Handle
Sword.Handle.att1_Handle.Rotation = Vector3.new(-0,0,130)
Sword.Handle.att1_Handle.Position = Vector3.new(1.75,0,0) --the align


Sword.Handle.Weld.C1 = CFrame.new(1, 0, 0) * CFrame.Angles(math.rad(0), math.rad(-90), 0)
Sword.Handle.Weld.C0 = CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(180), math.rad(0), 0)



slashsound1 = 978101945
slashsound2 = 608537390
stealth1 = 166196557
hum.HealthDisplayType = Enum.HumanoidHealthDisplayType.AlwaysOff
music("Stop")
drew = true
eColors = {
	Color3.new(1, 0, 0),
	Color3.new(0, 0, 0)
}
local alreadytouched = {}
hitsounds = {
	344936319,
	154965973,
	344936310,
	344936315
}
--local hat = game:GetService("Players").LocalPlayer.Character["gamer2"]

--local function align(part0, part1)

	
	local attachment0 = Instance.new("Attachment", part0)
	attachment0.Position = Vector3.new(2, 2, 0) --Custom Positioning Values Here
	attachment0.Orientation = Vector3.new(0, 0, -135) --Custom Rotationing Values here
	local attachment1 = Instance.new("Attachment", part1)
	local weldpos = Instance.new("AlignPosition", part0)
	weldpos.Attachment0 = attachment0
	weldpos.Attachment1 = attachment1
	weldpos.RigidityEnabled = true
	weldpos.ReactionForceEnabled = false
	weldpos.ApplyAtCenterOfMass = false
	weldpos.MaxForce = 20000
	weldpos.MaxVelocity = math.huge
	weldpos.Responsiveness = 200000000000000
	local weldrot = Instance.new("AlignOrientation", part0)
	weldrot.Attachment0 = attachment0
	weldrot.Attachment1 = attachment1
	weldrot.ReactionTorqueEnabled = false
	weldrot.PrimaryAxisOnly = false
	weldrot.MaxTorque = 200000000
	weldrot.MaxAngularVelocity = math.huge
	weldrot.Responsiveness = 200000000000000
--end
--align(hat.Handle, Part1)

Sword.HitBox.Touched:connect(function(ht)
	local hit = ht.Parent
	if attacking == true and checkIfNotPlayer(ht) and hit:FindFirstChildOfClass("Humanoid") and hit:FindFirstChildOfClass("Humanoid").Health > 0 then
		local hurt = true
		for i, v in pairs(alreadytouched) do
			if v == hit then
				hurt = false
			end
		end
		if hurt == true then
			table.insert(alreadytouched, hit)
			if hit:FindFirstChildOfClass("Humanoid").MaxHealth >= 1.0E100 then
				remote:FireServer("breakjoints", hit)
				if hit:FindFirstChildOfClass("Humanoid").Health > 0 then
				end
			else
				remote:FireServer("damage", hit:FindFirstChildOfClass("Humanoid"), math.random(2 * (hit:FindFirstChildOfClass("Humanoid").MaxHealth / 5), 3 * (hit:FindFirstChildOfClass("Humanoid").MaxHealth / 5)))
			end
			sound(hitsounds[math.random(1, #hitsounds)], ht.Position, 10, math.random(9, 11) / 10)
			if hit:FindFirstChildOfClass("Humanoid").Health <= 0 then
				remote:FireServer("breakjoints", hit)
				if hit:FindFirstChildOfClass("Humanoid").Health > 0 then
				end
			end
		end
	end
end)
function SPAGET()
	debounce = true
	noidle = false
	local z = sound(1335667136, root.Position, 10)
	wait(1.5)
	noidle = true
	for i = 1, 68 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 0.4)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0, -0.5, 0.1) * CFrame.Angles(math.rad(20), 0, 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-20 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(20 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-10), 0, 0), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.2)
	end
	for i = 1, 50 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 0.4)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0, -0.5, 0.1) * CFrame.Angles(math.rad(20), math.rad(20), 0), 0.6)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(150), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-20 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(150), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-50 + 1 * math.cos(sine / 8))), 0.6)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(0, 0, 0), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.2)
	end
	for i = 1, 50 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 0.4)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0, -0.5, 0.1) * CFrame.Angles(0, 0, 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-200), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-20 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-200), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(20 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(0, 0, 0), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.2)
	end
	for i = 1, 25 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 0.4)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0, -0.5, 0.1) * CFrame.Angles(0, 0, 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(40), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(10 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(40), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(0, 0, 0), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.2)
	end
	for i = 1, 300 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 0.4)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0, -0.5, 0.1) * CFrame.Angles(0, 0, 0), 0.2)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(40), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(10 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(40), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(math.random(-1, 1) * i, -1, math.random(-1, 1) * i) * CFrame.Angles(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.2)
	end
	noidle = false
	debounce = false
end

function togglesword()
	noidle = false
	attack = false
	if stealth == true then
		local spinspd = 35
		local i2 = 0
		for i = 1, 3 do
			sound(slashsound1, root.Position, 10, math.random(10, 13) / 10)
			for i = 1, 360 / spinspd do
				rs:wait()
				i2 = i2 + 1
				Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-i * spinspd), math.rad(-30 + i2 / (360 / spinspd) * 10), 0)
				larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, 0.2 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 - 1 * math.cos(sine / 8))), 0.2)
				rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(160 - i2 / (360 / spinspd) * 20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 - i2 / (360 / spinspd) * 20 + 1 * math.cos(sine / 8))), 0.4)
			end
		end
		sound(slashsound1, root.Position, 10, math.random(10, 13) / 10)
		for i = 1, 180 / spinspd do
			rs:wait()
			i2 = i2 + 1
			Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-i * spinspd), math.rad(-30 + i2 / (360 / spinspd) * 10), 0)
			larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, 0.2 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 - 1 * math.cos(sine / 8))), 0.2)
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(160 - i2 / (360 / spinspd) * 20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 - i2 / (360 / spinspd) * 20 + 1 * math.cos(sine / 8))), 0.4)
		end
		Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(180), math.rad(0), 0)
		for i = 1, 5 do
			rs:wait()
			larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, 0.2 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-80 - 1 * math.cos(sine / 8))), 0.2)
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(-0.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(100), math.rad(-40 - 1 * math.cos(sine / 16)), math.rad(-130 + 1 * math.cos(sine / 8))), 0.1)
		end
		Sword.Handle.Weld.Part0 = torso
		Sword.Handle.Weld.C1 = CFrame.new(1, 0, 0) * CFrame.Angles(math.rad(0), math.rad(-90), 0)
		Sword.Handle.Weld.C0 = CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(180), math.rad(0), 0)
		stealth = false
	else
		for i = 1, 5 do
			rs:wait()
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.5 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(30), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-90 + 1 * math.cos(sine / 8))), 0.2)
		end
		Sword.Handle.Weld.Part0 = rarm
		Sword.Handle.Weld.C1 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(-90), 0)
		Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(180), math.rad(0), 0)
		local spinspd = 35
		local i2 = 0
		for i = 1, 180 / spinspd do
			rs:wait()
			i2 = i2 + 1
			Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(180 + i * spinspd), math.rad(-10 + i2 / (360 / spinspd) * 10), 0)
			larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, 0.2 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 - 1 * math.cos(sine / 8))), 0.2)
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.5 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-90 + 1 * math.cos(sine / 8))), 0.1)
		end
		stealth = true
	end
	sound(stealth1, root.Position, 10, math.random(9, 11) / 10)
end
function tpdash()
	canjump = false
	local pos = root.Position
	local tppos = Instance.new("Attachment", root)
	tppos.Position = Vector3.new(0, 0, -1)
	local temp_alreadytouched = {}
	local sondpos = Instance.new("Attachment", root)
	sondpos.Position = Vector3.new(0, 0, -25)
	sound(695389867, sondpos.WorldPosition, 10, 2)
	sondpos:Destroy()
	hed.Weld.C0 = CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0)
	hed.Weld.C1 = CFrame.Angles(math.rad(-30), math.rad(0), 0)
	larm.Weld.C0 = CFrame.new(-0.8, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(115), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(30 - 1 * math.cos(sine / 8)))
	rarm.Weld.C0 = CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(80 - 1 * math.cos(sine / 16)), math.rad(60 + 1 * math.cos(sine / 8)))
	torso.Weld.C0 = CFrame.new(0, -1.5 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-45 - 2 * math.cos(sine / 16)), math.rad(0), math.rad(0 - 1 * math.cos(sine / 32)))
	lleg.Weld.C0 = CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-10 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8)))
	rleg.Weld.C0 = CFrame.new(0.5, 0.1 * math.cos(sine / 16), -0.5) * CFrame.Angles(math.rad(50 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8)))
	for i = 1, 50 do
		for i, z in pairs(findAllNearestTorso(root.Position, 5)) do
			local hit = z.Parent
			local hurt = true
			for i, v in pairs(temp_alreadytouched) do
				if v == hit then
					hurt = false
				end
			end
			if hurt == true then
				table.insert(temp_alreadytouched, hit)
				if hit:FindFirstChildOfClass("Humanoid").MaxHealth >= 1.0E100 then
					--remote:FireServer("breakjoints")
					if 0 < hit:FindFirstChildOfClass("Humanoid").Health then
					end
				else
					--remote:FireServer("damage", hit:FindFirstChildOfClass("Humanoid"), math.random(2 * (hit:FindFirstChildOfClass("Humanoid").MaxHealth / 5), 3 * (hit:FindFirstChildOfClass("Humanoid").MaxHealth / 5)))
				end
				sound(hitsounds[math.random(1, #hitsounds)], z.Position, 10, math.random(9, 11) / 10)
				if 0 >= hit:FindFirstChildOfClass("Humanoid").Health then
					--remote:FireServer("breakjoints")
					if 0 < hit:FindFirstChildOfClass("Humanoid").Health then
					end
				end
				rs:wait()
			end
		end
		root.CFrame = CFrame.new(tppos.WorldPosition) * CFrame.Angles(0, math.rad(root.Orientation.Y), 0)
	end
	tppos:Destroy()
	for i = 1, 5 do
		--Lightning(pos, root.Position, math.random(4, 6), 2, eColors[math.random(1, #eColors)], 0.5, 0.56)
	end
	for i = 1, 15 do
		rs:wait()
		hed.Weld.C0 = CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0)
		hed.Weld.C1 = CFrame.Angles(math.rad(-30), math.rad(0), 0)
		larm.Weld.C0 = CFrame.new(-0.8, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(115), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(30 - 1 * math.cos(sine / 8)))
		rarm.Weld.C0 = CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(-80 - 1 * math.cos(sine / 16)), math.rad(60 + 1 * math.cos(sine / 8)))
		torso.Weld.C0 = CFrame.new(0, -1.5 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-45 - 2 * math.cos(sine / 16)), math.rad(0), math.rad(0 - 1 * math.cos(sine / 32)))
		lleg.Weld.C0 = CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-30 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8)))
		rleg.Weld.C0 = CFrame.new(0.5, 0.1 * math.cos(sine / 16), -0.5) * CFrame.Angles(math.rad(50 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8)))
	end
	walking = true
	noidle = false
	attack = false
	attacking = false
	canjump = true
	local spinspd = 35
	local i2 = 0
	for i = 1, 3 do
		sound(slashsound1, root.Position, 10, math.random(10, 13) / 10)
		for i = 1, 360 / spinspd do
			rs:wait()
			i2 = i2 + 1
			Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(i * spinspd), math.rad(-30 + i2 / (360 / spinspd) * 10), 0)
			larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, 0.2 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 - 1 * math.cos(sine / 8))), 0.2)
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(160 + i2 / (360 / spinspd) * 5), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 + i2 / (360 / spinspd) * 10 + 1 * math.cos(sine / 8))), 0.4)
		end
	end
	Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(0, 0, 0)
	sound(stealth1, root.Position, 10, math.random(9, 11) / 10)
end
function taunt1()
	attack = false
	noidle = false
	for i = 1, 10 do
		rs:wait()
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55, 0) * CFrame.Angles(math.rad(160), math.rad(40), math.rad(-80)), 0.4)
	end
	sound(slashsound1, root.Position, 10, math.random(10, 13) / 10)
	for i = 1, 10 do
		rs:wait()
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(80)), 0.4)
	end
	sound(slashsound2, root.Position, 10, math.random(8, 10) / 10, 0.1)
	for i = 1, 12 do
		rs:wait()
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55, 0) * CFrame.Angles(math.rad(160), math.rad(0), math.rad(40)), 0.4)
		Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(i * 30), 0)
	end
	sound(slashsound1, root.Position, 10, math.random(10, 13) / 10)
	for i = 1, 10 do
		rs:wait()
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
	end
	sound(stealth1, root.Position, 10, math.random(9, 11) / 10)
	Sword.Handle.Weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(0, 0, 0)
end
function taunt2()
	noidle = true
	for i = 1, 50 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.3, -0.4) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0), 0.1)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(30), math.rad(30), 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, 0.2 - 0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(40), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-120 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(-30 - 1 * math.cos(sine / 16)), math.rad(-90 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-20 - 2 * math.cos(sine / 16)), math.rad(0), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(20 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-5 - 0.5 * math.cos(sine / 8))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-20 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(5 + 0.5 * math.cos(sine / 8))), 0.2)
	end
	noidle = false
end
mouse.KeyDown:connect(function(key)
	if debounce == false and plr == lplr then
		debounce = true
		noidle = true
		if key == "e" and stealth == true then
			animsync = true
			walking = true
			tpdash()
			animsync = false
			walking = false
		elseif key == "r" then
			animsync = true
			walking = true
			attack = true
			SPAGET()
			animsync = false
			walking = false
			attack = false
		elseif key == "q" then
			if stealth == true then
				animsync = true
				taunt1()
				animsync = false
			else
				walking = true
				animsync = true
				attack = true
				taunt2()
				animsync = false
				walking = false
				attack = false
			end
		elseif key == "f" then
			animsync = true
			togglesword()
			animsync = false
		end
		noidle = false
		attack = false
		delay(0.2, function()
			debounce = false
		end)
	end
end)
function attackone()
	for i = 1, 10 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0), 0.1)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-5), math.rad(80), 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(160), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(30 - 2 * math.cos(sine / 16)), math.rad(80), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-30 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-30 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.1)
	end
	sound(slashsound1, root.Position, 10, math.random(9, 11) / 10)
	attacking = true
	for i = 1, 10 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0), 0.1)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-5), math.rad(-20), 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(20 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-40 - 2 * math.cos(sine / 16)), math.rad(-20), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(40 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(40 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.1)
	end
end
function attacktwo()
	for i = 1, 10 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0), 0.1)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-5), math.rad(0), 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(160), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(10 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(30 - 2 * math.cos(sine / 16)), math.rad(0), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-30 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-30 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.1)
	end
	sound(slashsound1, root.Position, 10, math.random(9, 11) / 10)
	attacking = true
	for i = 1, 10 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0), 0.1)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-5), math.rad(80), 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-40 - 2 * math.cos(sine / 16)), math.rad(80), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(40 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(40 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.1)
	end
end
function attackthree()
	for i = 1, 10 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0), 0.1)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-5), math.rad(-40), 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(0), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-10 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(160), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(5 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(50 - 2 * math.cos(sine / 16)), math.rad(-40), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-50 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(-50 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.1)
	end
	sound(slashsound2, root.Position, 10, math.random(8, 10) / 10, 0.1)
	attacking = true
	for i = 1, 15 do
		rs:wait()
		hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -0.2) * CFrame.Angles(math.rad(-18), math.rad(0 + math.rad(0 + 2 * math.cos(sine / 2))), 0), 0.1)
		hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-5), math.rad(40), 0), 0.1)
		larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(-40), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-30 - 1 * math.cos(sine / 8))), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.55 - 0.1 * math.cos(sine / 16) / 2, -0.1 * math.cos(sine / 16)) * CFrame.Angles(math.rad(20), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-40 + 1 * math.cos(sine / 8))), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1 - 0.1 * math.cos(sine / 16), -2) * CFrame.Angles(math.rad(-45 - 2 * math.cos(sine / 16)), math.rad(40), math.rad(0 - 1 * math.cos(sine / 32))), 0.1)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(-2 - 0.5 * math.cos(sine / 8))), 0.1)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -0.95 + 0.1 * math.cos(sine / 16), 0) * CFrame.Angles(math.rad(0 + 1 * math.cos(sine / 16)), math.rad(0 - 1 * math.cos(sine / 16)), math.rad(2 + 0.5 * math.cos(sine / 8))), 0.1)
	end
end
local combo = 1
local combo2 = 2
local timer = 0
mouse.Button1Down:connect(function()
	if debounce == false and stealth == true and plr == lplr then
		alreadytouched = {}
		timer = 40
		noidle = true
		animsync = true
		debounce = true
		if combo == 1 then
			if combo2 == 1 then
				attackone()
			else
				attacktwo()
			end
			combo = 2
			animsync = false
		elseif combo == 2 then
			if combo2 == 2 then
				attackone()
			else
				attacktwo()
			end
			combo = 3
			animsync = false
		elseif combo == 3 then
			if combo2 == 1 then
				combo2 = 2
			else
				combo2 = 1
			end
			attackthree()
			combo = 1
			animsync = false
		end
		attacking = false
		noidle = false
		delay(0.1, function()
			debounce = false
		end)
	end
end)
if plr == lplr then
	GUI = Instance.new("ScreenGui", p.PlayerGui)
	GUI.Name = "BlackHoleKyu"
	textlabel = Instance.new("TextLabel", GUI)
	textlabel.AnchorPoint = Vector2.new(1, 1)
	textlabel.Position = UDim2.new(1, 505, 1, -5)
	textlabel.Size = UDim2.new(0, 500, 0, 400)
	textlabel.BorderSizePixel = 5
	textlabel.BorderColor3 = bordercolortitle
	textlabel.BackgroundColor3 = backgroundcolortitle
	textlabel.BackgroundTransparency = 0.1
	textlabel.TextTransparency = 0.1
	textlabel.TextColor3 = Color3.fromHSV(0, 0, 1)
	textlabel.TextScaled = true
	textlabel.TextYAlignment = Enum.TextYAlignment.Center
	textlabel.Font = Enum.Font.SciFi
end
guiopen = false
debouncebutton = false
function openhelp()
	if debouncebutton == false then
		if guiopen == false then
			debouncebutton = true
			textlabel:TweenPosition(UDim2.new(1, -5, 1, -5), Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.2)
			guiopen = true
			wait(0.2)
		else
			debouncebutton = true
			textlabel:TweenPosition(UDim2.new(1, 505, 1, -5), Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.2)
			guiopen = false
			wait(0.2)
		end
	end
	debouncebutton = false
end
if plr == lplr then
	openhelp()
end
mouse.KeyDown:connect(function(key)
	if plr == lplr and key == "h" then
		openhelp()
	end
end)
mouse.Button1Down:connect(function()
	if plr == lplr and debounce == false then
		debounce = true
		debounce = false
	end
end)
mouse.KeyDown:connect(function(key)
end)
local woosh = false
local debounce = false
mouse.KeyDown:connect(function(key)
	if plr == lplr and key == "g" then
		if musicplay then
			musicplay = false
			music("Stop")
		else
			musicplay = true
			music("Stop")
		end
	end
end)
local debounceimpact = false
function jumpimpact()
	if debounceimpact == false then
		debounceimpact = true
		if jumppower < -150 then
			jumppower = -150
		end
		shake(-jumppower / 5)
		sound(131436155, lleg.Position, 5, math.random(7, 8) / 10)
		for i = 1, -jumppower / 20 do
			rs:wait()
			hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0, 0, 0), 0.05)
			torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, jumppower / 20 - hum.HipHeight, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.05)
		end
		debounceimpact = false
	end
end
max = 0
function renderstepped()
	hum.MaxHealth = 5000
	if lplr ~= plr then
		if p.Character.Parent == nil then
			local model = Instance.new("Model")
			model.Name = p.Name
			p.Character = model
			for i, v in pairs(char:GetChildren()) do
				v.Parent = p.Character
			end
		end
		char = game.Workspace.non
		if p.Character.Parent ~= workspace then
			p.Character.Parent = workspace
		end
		for i, v in pairs(char:GetChildren()) do
			if v:IsA("Accoutrement") then
				if v.Handle:FindFirstChild("Mesh") then
					v.Handle:FindFirstChild("Mesh").Offset = Vector3.new()
					v.Handle.Transparency = 0
				end
			elseif v:IsA("BasePart") then
				v.Anchored = false
				if v:FindFirstChildOfClass("BodyPosition") then
					v:FindFirstChildOfClass("BodyPosition"):Destroy()
				end
				if v:FindFirstChildOfClass("BodyVelocity") then
					v:FindFirstChildOfClass("BodyVelocity"):Destroy()
				end
				if v:FindFirstChildOfClass("BodyGyro") and v:FindFirstChildOfClass("BodyGyro").Name ~= "lolnochara" then
					v:FindFirstChildOfClass("BodyGyro"):Destroy()
				end
				if v:FindFirstChild("Mesh") then
					v:FindFirstChild("Mesh").Offset = Vector3.new()
				end
				if not DebrisModel:FindFirstChild(v.Name .. "FORCEFIELD") then
					local force = Instance.new("Part", DebrisModel)
					force.Name = v.Name .. "FORCEFIELD"
					if v ~= hed then
						force.Size = v.Size + Vector3.new(1, 1, 1) * 0.2
					else
						force.Size = Vector3.new(1, 1, 1) * v.Size.Y + Vector3.new(1, 1, 1) * 0.2
					end
					force.CanCollide = false
					force.Transparency = 1
					force.Color = Color3.new(0, 1, 1)
					force.Material = Enum.Material.Neon
					newWeld(v, force, 0, 0, 0)
				elseif not DebrisModel:FindFirstChild(v.Name .. "FORCEFIELD"):FindFirstChildOfClass("Weld") then
					newWeld(v, DebrisModel:FindFirstChild(v.Name .. "FORCEFIELD"), 0, 0, 0)
				end
				if v.Name ~= "HumanoidRootPart" then
					v.Transparency = 0
				else
					v.Transparency = 1
				end
			end
		end
	end
end

mouse.KeyDown:connect(function(key)
	key = string.lower(key)
	if string.byte(key) == 50 then
		do
			local walkinglocal = true
			local keyConnection = mouse.KeyUp:connect(function(key)
				if string.byte(key) == 50 then
					walkinglocal = false
				end
			end)
			walking = true
			repeat
				rs:wait()
			until walkinglocal == false
			keyConnection:disconnect()
			walking = false
		end
	end
end)
remote.OnClientEvent:Connect(function(k)
	if k == "rs" then
		renderstepped()
	end
end)
rs:connect(function()
	if walking == false then
		change = 1
		movement = 20
		hum.WalkSpeed = 50
	else
		change = 0.5
		movement = 8
		hum.WalkSpeed = 20
	end
	for i, v in pairs(DebrisModel:GetChildren()) do
		if v.Name == "LIGHTNING" then
			local vm = v:FindFirstChildOfClass("BlockMesh")
			vm.Scale = vm.Scale - Vector3.new(0.05, 0.05, 0)
			if 0 >= vm.Scale.X then
				v:Destroy()
			end
		end
	end
	local ray1 = Ray.new(root.Position + Vector3.new(size, 0, 0), Vector3.new(0, -4, 0))
	local part1, endPoint = workspace:FindPartOnRay(ray1, char)
	local ray2 = Ray.new(root.Position - Vector3.new(size, 0, 0), Vector3.new(0, -4, 0))
	local part2, endPoint = workspace:FindPartOnRay(ray2, char)
	local ray3 = Ray.new(root.Position + Vector3.new(0, 0, size / 2), Vector3.new(0, -4, 0))
	local part3, endPoint = workspace:FindPartOnRay(ray3, char)
	local ray4 = Ray.new(root.Position - Vector3.new(0, 0, size / 2), Vector3.new(0, -4, 0))
	local part4, endPoint = workspace:FindPartOnRay(ray4, char)
	local ray5 = Ray.new(root.Position + Vector3.new(size, 0, size / 2), Vector3.new(0, -4, 0))
	local part5, endPoint = workspace:FindPartOnRay(ray5, char)
	local ray6 = Ray.new(root.Position - Vector3.new(size, 0, size / 2), Vector3.new(0, -4, 0))
	local part6, endPoint = workspace:FindPartOnRay(ray6, char)
	local ray7 = Ray.new(root.Position + Vector3.new(size, 0, -size / 2), Vector3.new(0, -4, 0))
	local part7, endPoint = workspace:FindPartOnRay(ray7, char)
	local ray8 = Ray.new(root.Position - Vector3.new(size, 0, -size / 2), Vector3.new(0, -4, 0))
	local part8, endPoint = workspace:FindPartOnRay(ray8, char)
	local ray = Ray.new(root.Position, Vector3.new(0, -6, 0))
	local part, endPoint = workspace:FindPartOnRay(ray, char)
	if part1 or part2 or part3 or part4 or part5 or part6 or part7 or part8 then
		jumped = false
	else
		endPoint = 0
		jumped = true
	end
	if plr == lplr and drew == true then
		if custom_outfits == true then
			p:ClearCharacterAppearance()
			if hed:FindFirstChild("face") then
				hed:FindFirstChild("face"):Destroy()
			end
		end
		if root.Position.Y < workspace.FallenPartsDestroyHeight + 200 then
			char:MoveTo(Vector3.new(0, 0, 0))
		end
		if 0 < hum.Health then
			if hum.Sit == false then
				if (root.Velocity * Vector3.new(1, 0, 1)).magnitude >= 5 and jumped == false then
					animation("Run")
				elseif jumped == true then
					didjump = true
					jumppower = root.Velocity.Y
					animation("Jump")
				elseif (torso.Velocity * Vector3.new(1, 0, 1)).magnitude < 5 then
					animation("Idle")
				end
			else
				animation("Sit")
			end
		end
		if didjump and jumped == false then
			jumpimpact(jumppower)
			didjump = false
		end
		if (torso.Velocity * Vector3.new(1, 0, 1)).magnitude >= 5 and jumped == false and noidle == false then
			if hed:FindFirstChild("Running") then
				hed.Running:Destroy()
			end
			if math.cos(sine / 4) / 2 <= -0.2 and sidestep == 0 then
				local a = sound(131436155, rleg.Position, 2, math.random(7, 8) / 10)
				a.Parent = rleg
				sidestep = 1
			end
			if math.cos(sine / 4) / 2 >= 0.2 and sidestep == 1 then
				local a = sound(131436155, lleg.Position, 2, math.random(7, 8) / 10)
				a.Parent = lleg
				sidestep = 0
			end
		end
		local asd = Vector3.new(math.random(-10000, 10000) / 10000, math.random(-10000, 10000) / 10000, math.random(-10000, 10000) / 10000)
		local asd2 = Vector3.new(math.random(-10000, 10000) / 10000, 0, math.random(-10000, 10000) / 10000)
		if skin_custom then
			hed.BrickColor = skin_color
			torso.BrickColor = skin_color
			rarm.BrickColor = skin_color
			larm.BrickColor = skin_color
			rleg.BrickColor = skin_color
			lleg.BrickColor = skin_color
		end
		remote:FireServer("rs")
		local stuffs = {
			hed.Weld.C0,
			hed.Weld.C1,
			larm.Weld.C0,
			rarm.Weld.C0,
			torso.Weld.C0,
			lleg.Weld.C0,
			rleg.Weld.C0
		}
		remote:FireServer("coords", stuffs, sine, pose, wingpose, animsync, walking, Sword.Handle.Weld.Part0, Sword.Handle.Weld.C0, Sword.Handle.Weld.C1)
	end
	if plr ~= lplr and drew then
		noidle = false
		if animsync == false then
			animation(pose)
		end
	end
	if drew then
		if blinktime > 0 then
			blinktime = blinktime - 1
		end
		if blinktime <= 0 then
			if blinking == false then
				blinking = true
				blinktime = 10
			else
				blinking = false
				blinktime = 250
			end
		end
	end
	sine = sine + change
end)
remote.OnClientEvent:Connect(function(k)
	if k == "stop" then
		script:Destroy()
		if plr == lplr then
			GUI:Destroy()
		end
	end
end)
    print("Clicked")
end)